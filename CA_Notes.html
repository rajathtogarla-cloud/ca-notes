<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchy Builder v3</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --bg-color: #f4f6f9;
            --line-color: #cbd5e1;
            --line-width: 2px;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --chapter-color: #4f46e5;
            --link-color: #059669;
            --chapter-bg: #fff;
            --level1-color: #d63384;
            --level2-color: #e67e22;
            --level3-color: #059669;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            background: white;
            padding: 0.8rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .brand-group {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .brand h1 {
            font-size: 1.4rem;
            background: var(--primary-gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }

        /* Subject Dropdown Styling */
        .subject-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #f8fafc;
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .subject-select {
            border: none;
            background: transparent;
            font-size: 0.95rem;
            font-weight: 600;
            color: #334155;
            padding: 4px 8px;
            outline: none;
            cursor: pointer;
            max-width: 200px;
        }

        .btn-subject-settings {
            background: white;
            border: 1px solid #cbd5e1;
            color: #64748b;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .btn-subject-settings:hover { background: #e2e8f0; color: #334155; }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .btn-action {
            font-size: 0.85rem;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.2s;
        }

        /* Undo/Redo Buttons */
        .btn-history {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            color: #475569;
            font-size: 1.1rem;
            padding: 4px 10px;
        }
        .btn-history:hover:not(:disabled) {
            background: #f1f5f9;
            border-color: #cbd5e1;
            transform: translateY(-1px);
        }
        .btn-history:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #f8fafc;
            border-color: #f1f5f9;
        }

        .btn-save {
            background: #ecfdf5;
            color: #059669;
            border-color: #a7f3d0;
        }
        .btn-save:hover { background: #d1fae5; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }

        .btn-reset {
            background: #fef2f2;
            color: #ef4444;
            border-color: #fca5a5;
        }
        .btn-reset:hover { background: #fee2e2; }

        .btn-resetdata {
            background: #fff;
            /* color: #ef4444; */
            border: 1px solid #e2e8f0;
            /* border-color: #fca5a5; */
            font-size: 1.2rem; /* Make the emoji slightly bigger */
            padding: 0 10px;   /* Adjust padding if it looks too wide/narrow */
        }
        .btn-resetdata:hover { 
            transform: scale(1.1);
            border-color: #fca5a5;
        }

        .btn-file-menu:hover {
            transform: scale(1.1);
            border-color: #fcd34d !important;
        }

        .btn-import {
            background: #eff6ff;
            color: #2563eb;
            border-color: #bfdbfe;
        }
        .btn-import:hover { background: #dbeafe; }

        /* JSON Action Buttons */
        .btn-json {
            background: #f3e8ff;
            color: #7e22ce;
            border-color: #d8b4fe;
        }
        .btn-json:hover { background: #e9d5ff; }

        /* New Cloud Button Style */
        .btn-cloud {
            background: #eff6ff;       /* Very light cloud blue */
            color: #1d4ed8;            /* Dark, readable blue text */
            border: 1px solid #bfdbfe; /* Soft blue border */
        }

        .btn-cloud:hover {
            background: #dbeafe;       /* Slightly deeper blue on hover */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /*1. CENTER NAV GROUP */
        .center-nav-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: #f1f5f9;
            padding: 4px 12px;
            border-radius: 30px;
        }

        /* 2. Base Style for Tabs */
        .nav-tab {
            padding: 8px 24px;
            border-radius: 8px; /* Smooth rounded corners */
            font-weight: 600;
            color: #64748b;
            background: transparent;
            border: 1px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        /* 3. Hover State for inactive tabs */
        .nav-tab:hover {
            background: #f1f5f9;
            color: #334155;
            transform: translateY(-1px);
        }

        /* 4. ACTIVE STATE - The "Attractive" Gradient */
        .nav-tab.active {
            /* Matches your Level 0 Node Gradient */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            /* box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4); */
            border-color: transparent;
            transform: translateY(-1px);
        }

        /* 5. Active State Hover */
        .nav-tab.active:hover {
            box-shadow: 0 6px 15px rgba(118, 75, 162, 0.5);
            filter: brightness(1.1);
        }

        /* NOTE & ADD TOOLS STYLES */
        .tool-container {
            display: flex;
            gap: 0.5rem;
        }

        .drag-tool {
            cursor: grab;
            font-size: 1.2rem;
            line-height: 1;
            padding: 4px 8px;
            border-radius: 4px;
            transition: transform 0.2s;
            user-select: none;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .drag-tool:hover {
            transform: scale(1.1);
        }
        .drag-tool:active {
            cursor: grabbing;
        }
        
        /* Specific Tool Colors */
        .note-tool:hover { background: #fffbeb; border-color: #fcd34d; }
        .add-tool:hover { background: #f0fdf4; border-color: #86efac; color: #16a34a; }

        .tool-separator {
            width: 1px;
            height: 20px;
            background: #cbd5e1;
        }

        .nav-tabs {
            display: flex;
            gap: 0.5rem;
        }

        /* --- View Container --- */
        .view-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex; /* Ensure it works as a flex parent */
            flex-direction: column;
        }

        .view-section {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            background: var(--bg-color);
            opacity: 0;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s ease;
        }

        .view-section.active-view {
            opacity: 1;
            pointer-events: auto;
            z-index: 10;
        }

        /* --- INPUT VIEW (3 Columns) --- */
        .input-wrapper {
            display: flex;
            height: 100%;
            padding: 1.5rem;
            gap: 1.5rem;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        /* Column 1 & 2 Sidebar Styling */
        .col-chapters, .col-level1 {
            width: 280px;
            background: white;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .col-header {
            padding: 1rem;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            color: #475569;
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .list-container {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        /* Draggable Items */
        .chapter-item, .level1-item {
            padding: 0.8rem 1rem;
            margin-bottom: 0.5rem;
            background: #fff;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid #eee;
            color: #334155;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            position: relative;
        }

        .chapter-item:hover, .level1-item:hover {
            background: #f1f5f9;
            transform: translateX(2px);
        }

        .chapter-item.active {
            background: #eef2ff;
            color: #4f46e5;
            border-color: #c7d2fe;
            font-weight: 600;
            border-left: 4px solid var(--chapter-color);
        }

        .level1-item.active {
            background: #fff0f7;
            border-color: #fce7f3;
            border-left: 4px solid var(--level1-color);
            color: #be185d;
            font-weight: 600;
        }

        /* Drag & Drop Visuals */
        .draggable-item {
            cursor: default; /* Default is non-drag */
        }
        
        .drag-handle {
            cursor: grab;
            color: #cbd5e1;
            margin-right: 8px;
            font-size: 1.2rem;
            line-height: 1;
            user-select: none;
        }
        
        .drag-handle:hover {
            color: #94a3b8;
        }
        
        .draggable-item.dragging {
            opacity: 0.5;
            background: #f8fafc;
            border: 1px dashed #94a3b8;
        }
        
        .draggable-item.drag-over {
            border-top: 2px solid #4f46e5;
        }

        /* Inline Edit Input */
        .inline-edit-input {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid #4f46e5;
            border-radius: 4px;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
        }

        /* Column 3: Editor Area */
        .col-editor {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-content {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            background: #fafbfc;
        }

        /* Inputs & Forms */
        .input-group {
            margin-bottom: 1.5rem;
        }
        
        .input-label {
            display: block;
            font-size: 0.85rem;
            color: #64748b;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .text-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }
        
        .text-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        /* Specific Colored Inputs for Editor */
        .text-input.chapter-input { border-left: 4px solid var(--chapter-color); color: #4f46e5; font-weight: 700; }
        .text-input.link-input { border-left: 4px solid var(--link-color); color: #2E6F40; }
        .text-input.level-1-input { border-left: 4px solid var(--level1-color); color: #be185d; font-weight: 600; }
        .text-input.level-2-input { border-left: 4px solid var(--level2-color); color: #c2410c; font-weight: 600; }
        .text-input.level-3-input { border-left: 4px solid var(--level3-color); color: var(--level3-color); font-weight: 600; }
        
        .desc-input { font-size: 0.9rem; color: #666; background: #fafafa; }

        .section-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-bottom: 1.5rem;
        }

        /* Level 2 & 3 Nesting */
        .level2-block {
            margin-bottom: 1.5rem;
        }

        .level2-header {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.8rem;
        }

        .level2-title-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .level3-list {
            padding-left: 1.5rem;
        }

        .level3-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            align-items: flex-start;
        }

        /* Buttons */
        .btn-add {
            background: #4f46e5;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            transition: transform 0.2s;
        }
        .btn-add:hover { background: #4338ca; transform: scale(1.1); }
        .btn-add.pink { background: var(--level1-color); }
        .btn-add.orange { background: var(--level2-color); width: auto; height: auto; padding: 0.2rem 0.8rem; border-radius: 4px; font-size: 0.8rem; }

        .btn-icon {
            background: none;
            border: none;
            color: #94a3b8;
            cursor: pointer;
            font-size: 1.2rem;
        }
        .btn-icon:hover { color: #ef4444; }

        .empty-msg {
            text-align: center;
            color: #94a3b8;
            padding: 2rem;
        }

        /* --- MODAL --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            
            /* PERFORMANCE FIX: Removed blur(2px) to stop lag */
            backdrop-filter: none; 
            
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal-overlay.open { opacity: 1; pointer-events: auto; }

        .modal {
            background: white;
            width: 600px;
            max-width: 90%;
            max-height: 90vh;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            padding: 2rem;
            display: flex;
            flex-direction: column;

            /* PERFORMANCE FIX: Force GPU rendering */
            transform: translateZ(0);
            will-change: transform;
        }

        /* Specific Larger Modal for Markdown Notes */
        .modal.large-modal {
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
        }

        .modal h2 { color: #334155; font-size: 1.5rem; }
        .modal p { color: #64748b; font-size: 0.95rem; line-height: 1.5; }
        .fmt-hint { 
            background: #f8fafc; padding: 1rem; border-radius: 8px; border: 1px solid #e2e8f0; font-family: monospace; font-size: 0.85rem !important; color: #475569 !important;
        }

        .import-textarea {
            width: 100%;
            height: 300px;
            padding: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        .import-textarea:focus { outline: none; border-color: #4f46e5; box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1); }

        /* Subjects Modal List */
        .subject-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border: 1px solid #e2e8f0;
            margin-bottom: 8px;
            border-radius: 6px;
            background: #fff;
        }
        .subject-list-item:hover {
            background: #f8fafc;
        }
        .subject-list-item.active-sub {
            border-left: 4px solid #4f46e5;
            background: #eff6ff;
        }

        /* Single Pane View for Notes Modal */
        .modal-body-single {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0; /* Important for flex nested scrolling */
            margin-top: 1rem;
            margin-bottom: 1rem;
            position: relative;
        }

        /* Both textarea and preview take full space, JS toggles visibility */
        .notes-textarea, .markdown-preview {
            width: 100%;
            flex: 1;
            height: 100%;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            padding: 1rem;
        }

        .notes-textarea {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            resize: none;
            line-height: 1.5;
        }
        .notes-textarea:focus { outline: none; border-color: #4f46e5; box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1); }

        /* Markdown Preview Styling - HIGH CONTRAST UPDATE */
        .markdown-preview {
            overflow-y: auto;
            background: #ffffff; 
            color: #000000;      
            line-height: 1.6;
            font-family: 'Segoe UI', sans-serif;
            display: none; 

            /* PERFORMANCE FIX: Optimization for scrolling */
            will-change: scroll-position;
            -webkit-overflow-scrolling: touch;
        }

        /* Show when active */
        .markdown-preview.active-pane { display: block; }
        .notes-textarea.active-pane { display: block; }
        .hidden-pane { display: none !important; }

        /* Typography for rendered markdown */
        .markdown-preview h1 { 
            font-size: 1.8em; 
            margin-bottom: 0.5em; 
            border-bottom: 2px solid #94a3b8; 
            padding-bottom: 0.2em; 
            color: #000000; /* Pure Black */
            font-weight: 800; 
        }
        .markdown-preview h2 { 
            font-size: 1.5em; 
            margin-top: 1em; 
            margin-bottom: 0.5em; 
            color: #000000; /* Pure Black */
            font-weight: 700; 
        }
        .markdown-preview h3 { 
            font-size: 1.2em; 
            margin-top: 1em; 
            margin-bottom: 0.5em; 
            font-weight: 600; 
            color: #000000; /* Pure Black */ 
        }
        .markdown-preview p { 
            margin-bottom: 1em; 
            color: #000000; /* Pure Black */
        }
        .markdown-preview ul, .markdown-preview ol { 
            padding-left: 1.5em; 
            margin-bottom: 1em; 
            color: #000000; /* Pure Black */
        }
        .markdown-preview li { margin-bottom: 0.3em; }
        
        /* Updated Blockquote for better visibility */
        .markdown-preview blockquote { 
            border-left: 4px solid #4f46e5; 
            padding-left: 1em; 
            margin: 1em 0; 
            color: #111111; /* Near Black */
            font-weight: 500;
            font-style: italic; 
            background: #f1f5f9; 
            padding: 1rem; 
            border-radius: 0 8px 8px 0; 
        }

        .markdown-preview code { background: #e2e8f0; padding: 0.2em 0.4em; border-radius: 4px; font-size: 0.9em; font-family: monospace; color: #d63384; font-weight: bold; }
        .markdown-preview pre { background: #0f172a; color: #f8fafc; padding: 1em; border-radius: 8px; overflow-x: auto; margin-bottom: 1em; }
        .markdown-preview pre code { background: none; color: inherit; padding: 0; color: #f1f5f9; }
        .markdown-preview a { color: #2563eb; text-decoration: underline; font-weight: 500; }
        .markdown-preview img { max-width: 100%; border-radius: 4px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin: 1em 0; }
        .markdown-preview hr { border: 0; border-top: 2px solid #cbd5e1; margin: 2em 0; }
        .markdown-preview table { width: 100%; border-collapse: collapse; margin-bottom: 1em; }
        .markdown-preview th, .markdown-preview td { border: 1px solid #94a3b8; padding: 8px; text-align: left; color: #000000; }
        .markdown-preview th { background: #f1f5f9; font-weight: 700; }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: auto; /* Push to bottom if needed */
        }
        
        .mode-badge {
            font-size: 0.75rem;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .badge-edit { background: #fff1f2; color: #e11d48; border: 1px solid #fda4af; }
        .badge-view { background: #ecfdf5; color: #059669; border: 1px solid #6ee7b7; }

        /* --- RESULT VIEW (Left-to-Right Tree) --- */
        #result-view {
            padding: 0; 
            overflow: hidden; /* Prevent the container itself from scrolling */
            background-image: radial-gradient(#e2e8f0 1px, transparent 1px);
            background-size: 24px 24px;
            display: flex;
            flex-direction: column;
            position: relative; /* Anchor for absolute children (toolbar) */
        }

        /* Scrolable area INSIDE result view where scale happens */
        #result-viewport {
            flex: 1; /* Fill remaining space exactly */
            width: 100%;
            height: 100%; /* Fallback */
            overflow: auto; /* Scrollbars appear here */
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            min-height: 0; /* Critical flex fix for scrolling */
        }

        /* Toolbar Top Right - FIXED POSITION RELATIVE TO CONTAINER */
        .result-toolbar {
            position: absolute; 
            top: 20px;        
            right: 20px;
            z-index: 100;   
            background: transparent;
            padding: 0;
            border: none;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 15px;
            pointer-events: none; /* Let clicks pass through the container */
        }

        /* Re-enable pointer events for buttons */
        .result-toolbar button, .result-toolbar .toggle-icon-btn, .result-toolbar .zoom-controls {
            pointer-events: auto;
        }

        .toolbar-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
        }

        .toggle-icon-btn {
            width: 45px;
            height: 45px;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 0;
            border: 2px solid white;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            line-height: 1;
            color: #64748b; /* Grey default */
        }

        .toggle-icon-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            color: #334155;
        }
        
        .toggle-icon-btn.btn-trash:hover { 
            color: #ef4444; 
            border-color: #CBCBCB; 
            /* background: #fef2f2;  */
        }
        .toggle-icon-btn.btn-trash { color: #ef4444; }

        /* State: Collapsed (Grey Clover) */
        .toggle-icon-btn.state-collapsed {
            filter: grayscale(0%);
            opacity: 0.7;
            color: #64748b;
        }
        
        /* State: Expanded (Green Clover) */
        .toggle-icon-btn.state-expanded {
            filter: grayscale(0%);
            opacity: 1;
            color: #10b981; /* Green tint */
            border-color: #CBCBCB !important; /* Your specific grey border */
        }

        /* Multi Select Default State (Greyed out until active) */
        #select-mode-btn {
            filter: grayscale(0%);
            opacity: 0.7;
        }
        /* Multi Select Active State */
        #select-mode-btn.selection-mode-active {
            filter: grayscale(0%);
            opacity: 1;
            /* background: #eff6ff; */
            color: #2563eb;
            border-color: #CBCBCB;
        }

        /* Zoom specific styles */
        .zoom-controls {
            background: white;
            border-radius: 30px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }
        .btn-zoom {
            width: 35px; 
            height: 35px;
            border-radius: 50%;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.2rem;
            color: #64748b;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-zoom:hover { background: #f1f5f9; color: #334155; }

        /* Label for the button on hover */
        .toggle-label {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
            position: absolute;
            right: 55px;
            top: 50%;
            transform: translateY(-50%);
        }
        .btn-wrapper { position: relative; }
        .btn-wrapper:hover .toggle-label { opacity: 1; }

        .chapters-container {
            display: flex;
            flex-direction: column;
            gap: 4rem; 
            padding-bottom: 4rem;
            padding-top: 3rem; 
            margin: 0 auto; 
            align-items: flex-start; 
            width: fit-content; 
            min-width: min-content;
            transform-origin: top left;
            transition: transform 0.2s ease-out;
        }

        /* Tree CSS - Left to Right Direction */
        .tree-ltr { display: flex; align-items: center; }
        .tree-ltr ul { display: flex; flex-direction: column; padding-left: 40px; position: relative; margin: 0; }
        .tree-ltr li { list-style-type: none; position: relative; padding: 10px 0; display: flex; align-items: center; }
        .tree-ltr li::before { content: ''; position: absolute; left: -40px; top: 50%; border-top: var(--line-width) solid var(--line-color); width: 40px; height: 0; }
        .tree-ltr li::after { content: ''; position: absolute; left: -40px; top: 0; bottom: 0; border-left: var(--line-width) solid var(--line-color); width: 0; }
        .tree-ltr > ul > li::before, .tree-ltr > ul > li::after { display: none; }
        .tree-ltr li:first-child::after { top: 50%; }
        .tree-ltr li:last-child::after { bottom: 50%; }
        .tree-ltr li:only-child::after { display: none; }
        .tree-ltr li:only-child::before { border-top-left-radius: 0; }

        /* Node Card Styling */
        .node {
            padding: 12px 16px;
            padding-left: 36px; 
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            
            /* WIDTH LOGIC */
            min-width: 140px;      /* 1. Minimum safety width */
            width: fit-content;    /* 2. Shrink-wrap to fit the content... */
            max-width: 90vw;       /* 3. ...but stop at screen edge */
            
            text-align: left;
            position: relative;
            z-index: 2;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            border: 2px solid transparent; 
        }

        .node:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 16px rgba(0,0,0,0.1); 
            z-index: 5; 
        }

        /* TITLE: The "Boss" of the Width */
        .node h4 { 
            font-size: 0.95rem; 
            margin-bottom: 0.2rem; 
            pointer-events: none;
            line-height: 1.3;
            
            /* Keep title on one line (mostly) so it defines the full width */
            /* white-space: nowrap;  */
            
            /* Safety: If title is wider than screen, allow it to wrap */
            overflow: hidden; 
            /* text-overflow: ellipsis;  */
        }

        /* DESCRIPTION: The "Follower" */
        .node p { 
            font-size: 0.8rem; 
            color: #64748b; 
            margin: 0; 
            pointer-events: none;
            line-height: 1.4;
            
            /* THE TRICK: Ignore my text length for width calculation */
            width: 0;           
            min-width: 110%;    /* Force it to fill the calculated space */
            
            /* Wrap nicely inside whatever space the Title provided */
            white-space: normal; 
            overflow-wrap: break-word; 
            word-break: break-word; 
        }

        /* Selected Node State (Multi-Select) */
        .node.node-selected {
            border-color: #ef4444 !important;
            box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.2);
            transform: scale(1.02);
        }

        /* Level Specific Styles */
        .node.level-0 { background: var(--primary-gradient); color: white; font-size: 1.1rem; padding: 16px 24px; padding-left: 42px; }
        .node.level-1 { background: white; border-left: 4px solid var(--level1-color); }
        .node.level-1 h4 { color: #be185d; }
        .node.level-1 p { color: #64748b; }
        .node.level-2 { background: white; border-left: 4px solid var(--level2-color); }
        .node.level-2 h4 { color: #c2410c; }
        .node.level-2 p { color: #64748b; }
        .node.level-3 { background: white; border-left: 4px solid var(--level3-color); }
        .node.level-3 h4 { color: var(--level3-color); }
        
        /* Drag & Drop in Visualization */
        .node[draggable="true"] { cursor: grab; }
        .node[draggable="true"]:active { cursor: grabbing; }
        .node.dragging-vis { opacity: 0.5; border: 2px dashed #94a3b8; background: #f1f5f9; }
        .node.drag-target { background: #d1fae5 !important; border-color: #059669 !important; box-shadow: 0 0 0 4px rgba(5, 150, 105, 0.2); transform: scale(1.02); z-index: 10; }

        /* Highlight when dragging the NOTE emoji over a node */
        .node.note-drag-target {
            box-shadow: 0 0 0 4px rgba(251, 191, 36, 0.4); /* Yellow glow */
            border-color: #f59e0b !important;
            transform: scale(1.05);
            z-index: 15;
            background: #fffbeb !important;
            /* If level 0 (gradient) override bg */
        }
        .node.level-0.note-drag-target {
             background: var(--primary-gradient) !important;
             filter: brightness(1.1);
        }

        /* Highlight for ADD Item Tool drag */
        .node.add-drag-target {
            box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.4); /* Green glow */
            border-color: #22c55e !important;
            transform: scale(1.05);
            z-index: 15;
            background: #f0fdf4 !important;
        }
        .node.level-0.add-drag-target {
            background: var(--primary-gradient) !important;
            filter: hue-rotate(90deg);
        }


        .expander {
            display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px;
            background: #fff; border: 1px solid #ccc; border-radius: 50%; position: absolute;
            right: -10px; top: 50%; transform: translateY(-50%); font-size: 10px; color: #555; z-index: 10;
        }
        .node.collapsed .expander { background: #eee; }
        .hidden { display: none !important; }

        /* Notes Bulb - UPDATED STYLES FOR DRAG LOGIC */
        .bulb-btn {
            position: absolute;
            top: 4px;
            left: 10px; 
            right: auto;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            
            /* HIDDEN BY DEFAULT (Changed from opacity 0 to display none) */
            display: none;
            opacity: 0;
            filter: grayscale(100%); 
            
            transition: all 0.2s;
            z-index: 20;
        }
        
        /* Existing Notes: Always Visible & Colored */
        .bulb-btn.has-notes {
            display: block;
            opacity: 1;
            filter: grayscale(0%);
            /* text-shadow: 0 0 5px white; */
        }
        
        .bulb-btn.has-notes:hover {
            transform: scale(1.2);
        }

        /* Removes box, background, and border for the emoji buttons */
        .emoji-btn {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            font-size: 1.5rem; /* Make emoji larger */
            padding: 0 8px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .emoji-btn:hover {
            transform: scale(1.1);
        }
        .emoji-btn:active {
            transform: scale(0.95);
        }

        /* --- KEYBOARD NAVIGATION STYLES --- */
        .node.key-focused {
            outline: 2px solid #2563eb !important;
            outline-offset: 2px;
            background-color: #eff6ff !important;
            border-color: #3b82f6 !important;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center;">
        <div class="spinner" style="border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div>
        <p style="margin-top: 15px; font-family: sans-serif; color: #555;">Syncing CA Notes...</p>
    </div>

    <style>
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    /* --- RESIZER HANDLES --- */
    .resizer {
        width: 3px;             /* Make it wider temporarily */
        background: #cbcbcb;         /* Make it bright RED so you can't miss it */
        opacity: 0.3;            /* Semi-transparent */
        cursor: col-resize;
        z-index: 100;            /* Force it on top of everything */
        
        /* Ensure it stretches top-to-bottom */
        height: 100%;            
        align-self: stretch;     
    }

    .resizer:hover, .resizer.resizing {
        background: #cbcbcb; 
    }

    body.resizing {
        cursor: col-resize;
        user-select: none;
    }
    </style>

    

<header>
    <div class="brand-group">
        <div class="brand">
            <h1>Hierarchy Builder v3</h1>
        </div>
        <div class="subject-group">
            <select id="subject-selector" class="subject-select" onchange="switchSubject(this.value)">
            </select>
            <button class="btn-subject-settings" onclick="openSubjectModal()" title="Manage Subject[s]">‚öôÔ∏è</button>
        </div>

        <div class="action-buttons">
            <button class="btn-action btn-history" id="btn-undo" onclick="undo()" disabled title="Undo (Ctrl+Z)">
                ‚Ü©
            </button>
            <button class="btn-action btn-history" id="btn-redo" onclick="redo()" disabled title="Redo (Ctrl+Y)">
                ‚Ü™
            </button>
            
            <button class="btn-action btn-file-menu" onclick="openFileMenu()" title="File Menu[i]" style="font-size: 1.2rem; background: #fff; border: 1px solid #e2e8f0;">
                üìÅ
            </button>
            
            <input type="file" id="json-upload" style="display:none" accept=".json" onchange="handleJSONImport(this)">

            <button class="btn-action btn-resetdata" onclick="resetAllData()" title="Reset Data">üìõ</button>
        </div>
    </div>
    
    <div class="center-nav-group">
        <div class="tool-container">
            <div class="drag-tool note-tool" id="draggable-note-tool" draggable="true" title="Drag onto a Node to add Note">
                ü™∂
            </div>
            <div class="drag-tool add-tool" id="draggable-add-tool" draggable="true" title="Drag onto a Node to add a Child (New Tab/Topic)">
                ‚ûï
            </div>
        </div>
        <div class="tool-separator"></div>
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchView('input')">1. Data Entry</button>
            <button class="nav-tab" onclick="switchView('result')">2. Visualization</button>
        </div>
    </div>
</header>

<div class="view-container">

    <div id="input-view" class="view-section active-view">
        <div class="input-wrapper">
            
            <div class="col-chapters" id="col-chapters" style="width: 280px;">
                <div class="col-header">
                    <span style="display: flex; align-items: baseline; gap: 8px;"">
                        Chapters
                        <span style="font-size: 0.9rem; color: #64748b; font-weight: 400; white-space: nowrap;">
                            Double click to View
                        </span>
                    </span>
                    
                    <div class="header-actions">
                        <button class="btn-add" onclick="addChapter()">+</button>
                    </div>
                </div>
                <div class="list-container" id="chapters-list">
                </div>
            </div>

            <div class="resizer" id="resizer-1"></div>

            <div class="col-level1" id="col-level1" style="width: 280px;">
                <div class="col-header">
                    <span>Level 1 Tabs</span>
                    <div class="header-actions">
                        <button class="btn-add pink" onclick="addLevel1()">+</button>
                    </div>
                </div>
                <div class="list-container" id="level1-list">
                    <div class="empty-msg">Select a Chapter</div>
                </div>
            </div>

            <div class="resizer" id="resizer-2"></div>

            <div class="col-editor">
                <div class="col-header">
                    <span>Content Editor</span>
                    <span id="editor-status" style="font-weight:400; font-size:0.9rem; color:#64748b;"></span>
                </div>
                <div class="editor-content" id="editor-area">
                    <div class="empty-msg">Select a Level 1 Tab to edit details</div>
                </div>
            </div>

        </div>
    </div>

    <div id="result-view" class="view-section">
        
        <div class="result-toolbar">
            
            <!-- Zoom Controls -->
            <div class="toolbar-group">
                <div class="zoom-controls">
                    <button class="btn-zoom" onclick="zoomIn()" title="Zoom In">+</button>
                    <button class="btn-zoom" onclick="resetZoom()" title="Reset Zoom">‚ü≤</button>
                    <button class="btn-zoom" onclick="zoomOut()" title="Zoom Out">-</button>
                </div>
            </div>

            <!-- Collapse/Expand -->
            <div class="btn-wrapper">
                <button id="tree-toggle-btn" class="toggle-icon-btn state-collapsed" onclick="toggleTreeState()">
                    üçÅ
                </button>
                <div class="toggle-label" id="toggle-label-text">Expand All</div>
            </div>

            <!-- Multi Select Toggle -->
            <div class="btn-wrapper">
                <button id="select-mode-btn" class="toggle-icon-btn" onclick="toggleSelectionMode()">
                    ‚òëÔ∏è
                </button>
                <div class="toggle-label">Select Mode</div>
            </div>

            <!-- Multi Delete Action (Hidden unless selected) -->
            <div class="btn-wrapper" id="delete-selected-wrapper" style="display:none;">
                <button class="toggle-icon-btn btn-trash" onclick="deleteSelectedNodes()">
                    üóëÔ∏è
                </button>
                <div class="toggle-label">Delete Selected</div>
            </div>

        </div>

        <div id="result-viewport">
            <div id="result-container" class="chapters-container">
            </div>
        </div>
    </div>

</div>

<!-- NEW: IMPORT CHOICE MODAL -->
<div id="import-choice-modal" class="modal-overlay">
    <div class="modal" style="width: 400px; text-align: center;">
        <h2>Import Data</h2>
        <p>Choose an import method:</p>
        <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
            <button class="btn-action btn-import" onclick="chooseImport('bulk')">
                <span>üìã</span> Text / Bulk
            </button>
            <button class="btn-action btn-json" onclick="chooseImport('json')">
                <span>üìÑ</span> JSON File
            </button>
        </div>
        <div class="modal-actions" style="justify-content: center; margin-top: 1.5rem;">
            <button class="btn-action btn-reset" onclick="closeImportChoiceModal()">Cancel</button>
        </div>
    </div>
</div>

<div id="export-choice-modal" class="modal-overlay">
    <div class="modal" style="width: 450px; text-align: center;"> <h2>Export Data</h2>
        <p>Choose an export format:</p>
        <div style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center; margin-top: 1rem;">
            <button class="btn-action btn-json" onclick="chooseExport('json')">
                <span>{ }</span> JSON Data
            </button>
            
            <button class="btn-action btn-cloud" onclick="saveToCloud()" title="Ctrl + Enter">
                <span>üåê</span> Save to Cloud
            </button>

            <button class="btn-action btn-save" onclick="chooseExport('html')">
                <span>üñ•Ô∏è</span> Standalone HTML
            </button>
        </div>
        <div class="modal-actions" style="justify-content: center; margin-top: 1.5rem;">
            <button class="btn-action btn-reset" onclick="closeExportChoiceModal()">Cancel</button>
        </div>
    </div>
</div>

<div id="import-modal" class="modal-overlay">
    <div class="modal">
        <h2>Bulk Import</h2>
        <p>Paste your content below to import into the <strong>current Subject</strong>.</p>
        <div class="fmt-hint">
            <strong>Format Guide:</strong><br>
            Chapter Title @pg 1 <span style="color:#999">(No hash)</span><br>
            # Level 1 Tab @pg 5 <span style="color:#999">(One #)</span><br>
            ## Level 2 Topic @pg 12 <span style="color:#999">(Two ##)</span><br>
            ### Level 3 Detail @pg 15 <span style="color:#999">(Three ###)</span>
        </div>
        <textarea id="import-text" class="import-textarea" placeholder="Chapter 1&#10;  Introduction Tab&#10;    Topic A&#10;      Detail 1&#10;      Detail 2&#10;Chapter 2&#10;  ..."></textarea>
        <div class="modal-actions">
            <button class="btn-action btn-reset" onclick="closeImportModal()">Cancel</button>
            <button class="btn-action btn-save" onclick="processImport()">Import Data</button>
        </div>
    </div>
</div>

<div id="file-menu-modal" class="modal-overlay">
    <div class="modal" style="width: 900px; max-width: 95%;">
        
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 1rem;">
            <h2 style="margin:0; font-size:1.4rem; color:#334155;"></h2> <!--File Manager-->
            <button class="btn-icon" onclick="closeFileMenu()" style="font-size:1.2rem;">√ó</button>
        </div>

        <div style="display: flex; gap: 2rem; align-items: flex-start;">
            
            <div style="flex: 1; text-align: center;">
                <h2 style="font-size: 1.2rem; margin-bottom: 0.5rem;">Import Data</h2>
                <p style="margin-bottom: 1rem;">Choose an import method:</p>
                <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                    <button class="btn-action btn-import" onclick="closeFileMenu(); chooseImport('bulk')">
                        <span>üìã</span> Text / Bulk
                    </button>
                    <button class="btn-action btn-json" onclick="closeFileMenu(); chooseImport('json')">
                        <span>üìÑ</span> JSON File
                    </button>
                </div>
            </div>

            <div style="width: 1px; background: #e2e8f0; align-self: stretch;"></div>

            <div style="flex: 1; text-align: center;">
                <h2 style="font-size: 1.2rem; margin-bottom: 0.5rem;">Export Data</h2>
                <p style="margin-bottom: 1rem;">Choose an export format:</p>
                <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                    <button class="btn-action btn-json" onclick="closeFileMenu(); chooseExport('json')">
                        <span>{ }</span> JSON Data
                    </button>
                    
                    <button class="btn-action btn-cloud" onclick="closeFileMenu(); saveToCloud()" title="Ctrl + Enter">
                        <span>üåê</span> Save to Cloud
                    </button>

                    <button class="btn-action btn-save" onclick="closeFileMenu(); chooseExport('html')">
                        <span>üñ•Ô∏è</span> Standalone HTML
                    </button>
                </div>
            </div>

        </div>

        <div class="modal-actions" style="justify-content: center; margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #f1f5f9;">
            <button class="btn-action btn-reset" onclick="closeFileMenu()">Close</button>
        </div>
    </div>
</div>

<div id="subjects-modal" class="modal-overlay">
    <div class="modal">
        <h2>Manage Subjects</h2>
        <div style="display:flex; gap:0.5rem; margin-bottom:1rem;">
            <input type="text" id="new-subject-input" class="text-input" placeholder="New Subject Name" />
            <button class="btn-action btn-save" onclick="createNewSubject()">Add</button>
        </div>
        
        <div id="subject-list-container" style="flex:1; overflow-y:auto; border:1px solid #e2e8f0; border-radius:8px; padding:0.5rem; background:#fafbfc;">
        </div>

        <div class="modal-actions">
            <button class="btn-action btn-reset" onclick="closeSubjectModal()">Close</button>
        </div>
    </div>
</div>

<div id="notes-modal" class="modal-overlay">
    <div class="modal large-modal" style="border-top: 5px solid #6366f1;">
        <div style="display:flex; justify-content:space-between; align-items:center; padding-bottom: 1rem; border-bottom: 1px solid #e2e8f0; margin-bottom: 1rem;">
            <h2 style="margin:0; color: #1e293b;">Notes & Documentation</h2>
            
            <div style="display:flex; align-items:center; gap: 1rem;">
                <div id="note-mode-badge" class="mode-badge" style="background-color: #ecfdf5; color: #059669; border: 1px solid #10b981; padding: 2px 8px; border-radius: 4px; font-weight: bold; font-size: 0.9rem;">VIEW MODE</div>
                
                <div style="display:flex; gap: 0.5rem; align-items: center;">
                    <button onclick="deleteCurrentNote()" style="background-color: #fee2e2; color: #dc2626; border: 1px solid #f87171; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-weight: 500;">
                        Clear
                    </button>
                    
                    <button id="btn-note-action" onclick="toggleNoteMode()" class="emoji-btn" title="Edit">‚úèÔ∏è</button>
                    
                    <button onclick="closeNotesModal()" title="Esc" style="background-color: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; padding: 2px 8px; border-radius: 4px; cursor: pointer;">Close</button>                </div>
            </div>
        </div>
        
        <div class="modal-body-single">
            <textarea id="note-content" class="hidden-pane" style="width: 100%; height: 100%; border: 1px solid #e2e8f0; border-radius: 8px; padding: 1rem;" placeholder="Use Markdown syntax..."></textarea>
            <div id="note-preview" class="markdown-preview active-pane"></div>
        </div>
    </div>
</div>

<script id="app-logic">
    // --- State Management ---
    const STORAGE_KEY = 'HIERARCHY_BUILDER_V3';
    const generateId = () => 'id_' + Math.random().toString(36).substr(2, 9);

    /* --- EMBEDDED_DATA_START --- */
    const embeddedData = null;
    /* --- EMBEDDED_DATA_END --- */

    const defaultExample = {
        id: 'sub_default',
        name: 'Example Subject',
        chapters: [
            {
                id: 'chap1',
                title: 'Chapter 1',
                desc: 'Introduction',
                notes: '# Welcome\n\nThis is a sample note using **Markdown**.',
                children: [
                    { 
                        id: 'l1_1', title: '1. Basics', desc: 'Core concepts', notes: '## Core Concepts',
                        children: [
                            { id: 'l2_1', title: '1. Definition', desc: 'Standard Def', children: [{id:'l3_1', title:'1. Term A', desc: 'Detail A', children:[]}] }
                        ] 
                    }
                ]
            }
        ]
    };

    let appState = {
        subjects: [JSON.parse(JSON.stringify(defaultExample))],
        activeSubjectId: 'sub_default',
        activeChapterId: 'chap1',
        activeLevel1Id: 'l1_1',
        expandedNodes: new Set() 
    };

    // --- View & Interaction State ---
    let zoomLevel = 1;
    let isSelectionMode = false;
    let selectedNodeIds = new Set();
    // Default to false to start collapsed
    let isTreeFullyExpanded = false; 
    let pendingFocusNodeId = null;

    // --- History / Undo / Redo State ---
    let historyStack = [];
    let historyIndex = -1;
    let isHistoryNavigating = false;
    const MAX_HISTORY = 50;

    // --- Drag State ---
    let dragSrcIndex = null;
    let dragType = null; // 'chapter' or 'level1'
    let visDragId = null; // ID for drag in Visualization view
    let currentNoteNodeId = null; // For Notes
    let isNoteEditMode = false; // Track note modal state
    
    // --- Tool Drag State ---
    let isDraggingNoteTool = false;
    let isDraggingAddTool = false;

    // --- Helpers ---
    function getActiveSubject() {
        return appState.subjects.find(s => s.id === appState.activeSubjectId) || appState.subjects[0];
    }

    function getActiveChapter() { 
        const sub = getActiveSubject();
        if(!sub || !sub.chapters) return null;
        return sub.chapters.find(c => c.id === appState.activeChapterId); 
    }

    function getActiveLevel1() {
        const chap = getActiveChapter();
        if (!chap) return null;
        return chap.children.find(l1 => l1.id === appState.activeLevel1Id);
    }

    // --- CHOICE MODAL LOGIC ---
    function openImportChoiceModal() {
        document.getElementById('import-choice-modal').classList.add('open');
    }
    function closeImportChoiceModal() {
        document.getElementById('import-choice-modal').classList.remove('open');
    }
    function chooseImport(type) {
        closeImportChoiceModal();
        if (type === 'bulk') {
            openImportModal();
        } else if (type === 'json') {
            document.getElementById('json-upload').click();
        }
    }

    function openExportChoiceModal() {
        document.getElementById('export-choice-modal').classList.add('open');
    }
    function closeExportChoiceModal() {
        document.getElementById('export-choice-modal').classList.remove('open');
    }
    function chooseExport(type) {
        closeExportChoiceModal();
        if (type === 'json') {
            exportJSON();
        } else if (type === 'html') {
            downloadHTML();
        }
    }

    // --- JSON Export/Import Logic ---
    function exportJSON() {
        const dataStr = JSON.stringify({
            subjects: appState.subjects,
            activeSubjectId: appState.activeSubjectId,
            version: 'v3'
        }, null, 2);
        const blob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const d = new Date();
        const timestamp = `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}`;
        a.download = `hierarchy_data_${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function handleJSONImport(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                if (data.subjects && Array.isArray(data.subjects)) {
                    if(confirm("This will overwrite your current data. Continue?")) {
                        appState.subjects = data.subjects;
                        appState.activeSubjectId = data.activeSubjectId || data.subjects[0].id;
                        saveData();
                        loadData(); // Re-initialize UI
                        alert("Import Successful!");
                    }
                } else {
                    alert("Invalid JSON format: Missing 'subjects' array.");
                }
            } catch (err) {
                alert("Error parsing JSON file.");
                console.error(err);
            }
            input.value = ''; // Reset input
        };
        reader.readAsText(file);
    }

    // --- History Logic ---
    function recordState() {
        if (isHistoryNavigating) return;

        // Save the ENTIRE subjects structure
        const currentState = JSON.stringify({
            subjects: appState.subjects,
            activeSubjectId: appState.activeSubjectId
        });
        
        if (historyIndex >= 0 && historyStack[historyIndex] === currentState) return;

        if (historyIndex < historyStack.length - 1) {
            historyStack = historyStack.slice(0, historyIndex + 1);
        }

        historyStack.push(currentState);
        
        if (historyStack.length > MAX_HISTORY) {
            historyStack.shift();
        } else {
            historyIndex++;
        }
        
        updateUndoRedoUI();
    }

    function restoreState(jsonString) {
        const data = JSON.parse(jsonString);
        appState.subjects = data.subjects;
        appState.activeSubjectId = data.activeSubjectId;
        
        // Validation: Ensure active IDs exist
        const sub = getActiveSubject();
        if(!sub) {
            appState.activeSubjectId = appState.subjects[0].id;
        }
        
        // Reset specific selection pointers if invalid
        const chap = getActiveChapter();
        if(!chap) {
             const s = getActiveSubject();
             if(s.chapters.length > 0) {
                 appState.activeChapterId = s.chapters[0].id;
                 if(s.chapters[0].children.length > 0) appState.activeLevel1Id = s.chapters[0].children[0].id;
             }
        }
        
        saveData(false); // No history record
        renderSubjectSelector();
        renderInputView();
        renderVisualizer();
    }

    function undo() {
        if (historyIndex > 0) {
            isHistoryNavigating = true;
            historyIndex--;
            restoreState(historyStack[historyIndex]);
            isHistoryNavigating = false;
            updateUndoRedoUI();
        }
    }

    function redo() {
        if (historyIndex < historyStack.length - 1) {
            isHistoryNavigating = true;
            historyIndex++;
            restoreState(historyStack[historyIndex]);
            isHistoryNavigating = false;
            updateUndoRedoUI();
        }
    }

    function updateUndoRedoUI() {
        document.getElementById('btn-undo').disabled = historyIndex <= 0;
        document.getElementById('btn-redo').disabled = historyIndex >= historyStack.length - 1;
    }

    // Keyboard Shortcut: Ctrl + Enter to Save
    document.addEventListener('keydown', function(event) {
        if (event.ctrlKey && event.key === 'Enter') {
            event.preventDefault(); // Prevents adding a new line if you are typing
            saveToCloud();          // Triggers your save function
        }
    });

    // --- UPDATED KEYBOARD SHORTCUTS ---
    document.addEventListener('keydown', (e) => {
        const isNotesOpen = document.getElementById('notes-modal').classList.contains('open');
        const isCtrlOrMeta = e.ctrlKey || e.metaKey;

        // 1. Undo (Ctrl + Z) - Context Aware
        if (isCtrlOrMeta && e.key === 'z' && !e.shiftKey) {
            if (isNotesOpen) return; // Let browser handle text undo
            e.preventDefault(); 
            undo();
        }

        // 2. Redo (Ctrl + Y) - Context Aware
        if (isCtrlOrMeta && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) {
            if (isNotesOpen) return; // Let browser handle text redo
            e.preventDefault(); 
            redo();
        }

        // 3. GLOBAL SAVE (Ctrl + Enter) 
        // Always triggers the main Cloud Save, even if notes are open
        if (isCtrlOrMeta && e.key === 'Enter') {
            e.preventDefault();
            saveToCloud(); 
        }

        // 4. NOTE SAVE (Shift + Enter)
        // Only works if the Notes Modal is open
        if (e.shiftKey && e.key === 'Enter') {
            if (isNotesOpen) {
                e.preventDefault(); // Prevent newline if needed (or keep it if you prefer)
                toggleNoteMode();   // Toggles from Edit -> View (Saving)
            }
        }

        // 5. Escape Key
        if (e.key === 'Escape') {
            if (isNotesOpen) closeNotesModal();
        }
    });

    // --- Persistence ---
    function saveData(record = true) {
        try { 
            // Save minimal state needed for reload
            const exportData = {
                subjects: appState.subjects,
                activeSubjectId: appState.activeSubjectId
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(exportData)); 
            if(record) recordState();
        } catch (e) {}
    }

    function loadData() {
        try {
            let data = null;

            if (embeddedData && typeof embeddedData === 'object') {
                data = embeddedData; // From baked HTML file
            } else {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) data = JSON.parse(saved);
            }

            if (data) {
                // New format
                appState.subjects = data.subjects || [JSON.parse(JSON.stringify(defaultExample))];
                appState.activeSubjectId = data.activeSubjectId || appState.subjects[0].id;
            }
            
            // Initialization
            const sub = getActiveSubject();
            if (sub.chapters.length > 0) {
                appState.activeChapterId = sub.chapters[0].id;
                if (sub.chapters[0].children.length > 0) {
                    appState.activeLevel1Id = sub.chapters[0].children[0].id;
                } else {
                    appState.activeLevel1Id = null;
                }
            } else {
                appState.activeChapterId = null;
                appState.activeLevel1Id = null;
            }

            // === FIX: INITIAL RENDERING AND COLLAPSED STATE ===
            renderSubjectSelector();
            renderInputView(); // Ensure input view is rendered immediately

            // Start in "Collapse All" mode (Nodes are closed)
            collapseAll(); // Populate expandedNodes set with all IDs to collapse them
            isTreeFullyExpanded = false;

            // Ensure Toggle Button reflects this initial state
            const btn = document.getElementById('tree-toggle-btn');
            const label = document.getElementById('toggle-label-text');
            if(btn && label) {
                btn.classList.remove('state-expanded');
                btn.classList.add('state-collapsed');
                label.innerText = "Expand All";
            }
            
            // Visualizer is rendered by collapseAll() but ensuring it here is safe
            renderVisualizer(); 

            recordState();

        } catch (e) { console.error("Load failed", e); }
    }

    function downloadHTML() {
        const dataJson = JSON.stringify({
            subjects: appState.subjects,
            activeSubjectId: appState.activeSubjectId
        }, null, 2);
        
        document.querySelectorAll('input').forEach(input => input.setAttribute('value', input.value));
        document.querySelectorAll('textarea').forEach(ta => ta.innerHTML = ta.value);

        let htmlContent = document.documentElement.outerHTML;
        const markerStart = '/* --- EMBEDDED_DATA_START --- */';
        const markerEnd = '/* --- EMBEDDED_DATA_END --- */';
        const newContent = `${markerStart}\n    const embeddedData = ${dataJson};\n    ${markerEnd}`;
        const regex = /\/\* --- EMBEDDED_DATA_START --- \*\/[\s\S]*?\/\* --- EMBEDDED_DATA_END --- \*\//;
        const updatedHtml = htmlContent.replace(regex, newContent);
        
        const d = new Date();
        const timestamp = `${String(d.getDate()).padStart(2,'0')}-${String(d.getMonth()+1).padStart(2,'0')}-${d.getFullYear()}_${String(d.getHours()).padStart(2,'0')}-${String(d.getMinutes()).padStart(2,'0')}`;
        const rawTitle = document.title;
        const safeTitle = rawTitle.replace(/[^a-z0-9]/gi, '_').replace(/_+/g, '_');
        const filename = `${safeTitle}_${timestamp}.html`;

        const blob = new Blob([updatedHtml], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function resetAllData() {
        if(confirm("Are you sure? This will erase all your custom data.")) {
            localStorage.removeItem(STORAGE_KEY);
            appState.subjects = [JSON.parse(JSON.stringify(defaultExample))];
            appState.activeSubjectId = appState.subjects[0].id;
            appState.activeChapterId = 'chap1';
            appState.activeLevel1Id = 'l1_1';
            saveData(); 
            loadData(); // Re-run load data to ensure collapsed state
        }
    }

    // --- Subject Management Logic ---
    function renderSubjectSelector() {
        const select = document.getElementById('subject-selector');
        select.innerHTML = '';
        appState.subjects.forEach(sub => {
            const opt = document.createElement('option');
            opt.value = sub.id;
            opt.innerText = sub.name;
            if(sub.id === appState.activeSubjectId) opt.selected = true;
            select.appendChild(opt);
        });
    }

    function switchSubject(id) {
        appState.activeSubjectId = id;
        
        // Reset internal pointers for this subject
        const sub = getActiveSubject();
        if(sub.chapters.length > 0) {
            appState.activeChapterId = sub.chapters[0].id;
            if(sub.chapters[0].children.length > 0) {
                appState.activeLevel1Id = sub.chapters[0].children[0].id;
            } else {
                appState.activeLevel1Id = null;
            }
        } else {
            appState.activeChapterId = null;
            appState.activeLevel1Id = null;
        }

        saveData();
        renderInputView();
        
        // On subject switch, respect current toggle state or reset to collapsed?
        // Let's reset to collapsed for consistency
        collapseAll();
        isTreeFullyExpanded = false;
        const btn = document.getElementById('tree-toggle-btn');
        const label = document.getElementById('toggle-label-text');
        if(btn) {
             btn.classList.remove('state-expanded');
             btn.classList.add('state-collapsed');
             label.innerText = "Expand All";
        }
    }

    function openSubjectModal() {
        document.getElementById('subjects-modal').classList.add('open');
        renderSubjectList();
    }

    function closeSubjectModal() {
        document.getElementById('subjects-modal').classList.remove('open');
    }

    function renderSubjectList() {
        const container = document.getElementById('subject-list-container');
        container.innerHTML = '';
        
        appState.subjects.forEach(sub => {
            const div = document.createElement('div');
            div.className = `subject-list-item ${sub.id === appState.activeSubjectId ? 'active-sub' : ''}`;
            
            div.innerHTML = `
                <input type="text" class="text-input" style="flex:1; margin-right:10px;" value="${sub.name}" onchange="renameSubject('${sub.id}', this.value)" />
                <button class="btn-icon" onclick="deleteSubject('${sub.id}')" title="Delete Subject">√ó</button>
            `;
            container.appendChild(div);
        });
    }

    function createNewSubject() {
        const input = document.getElementById('new-subject-input');
        const name = input.value.trim();
        if(!name) return;
        
        const newSub = {
            id: generateId(),
            name: name,
            chapters: []
        };
        appState.subjects.push(newSub);
        input.value = '';
        
        saveData();
        renderSubjectList();
        renderSubjectSelector();
    }

    function renameSubject(id, newName) {
        const sub = appState.subjects.find(s => s.id === id);
        if(sub) {
            sub.name = newName;
            saveData();
            renderSubjectSelector();
        }
    }

    function deleteSubject(id) {
        if(appState.subjects.length <= 1) {
            alert("You must have at least one subject.");
            return;
        }
        if(!confirm("Delete this subject and all its chapters?")) return;

        appState.subjects = appState.subjects.filter(s => s.id !== id);
        
        // If we deleted the active one, switch to the first available
        if(appState.activeSubjectId === id) {
            switchSubject(appState.subjects[0].id);
        } else {
            saveData();
        }
        
        renderSubjectList();
        renderSubjectSelector();
    }

    // --- Import Feature ---
    function openImportModal() {
        document.getElementById('import-modal').classList.add('open');
        document.getElementById('import-text').focus();
    }
    
    function closeImportModal() {
        document.getElementById('import-modal').classList.remove('open');
        document.getElementById('import-text').value = '';
    }

    function processImport() {
        const text = document.getElementById('import-text').value;
        if (!text.trim()) return closeImportModal();

        const currentSubject = getActiveSubject();
        const newChapters = [];

        const lines = text.split('\n');
        let currentChap = null;
        let currentL1 = null;
        let currentL2 = null;
        
        lines.forEach(line => {
            const rawLine = line.trim();
            if (!rawLine) return;

            // 1. Determine Level based on Hash (#) prefixes
            let level = 0; // 0=Chapter, 1=L1, 2=L2, 3=L3
            let cleanText = rawLine;

            if (rawLine.startsWith('###')) {
                level = 3;
                cleanText = rawLine.substring(3).trim();
            } else if (rawLine.startsWith('##')) {
                level = 2;
                cleanText = rawLine.substring(2).trim();
            } else if (rawLine.startsWith('#')) {
                level = 1;
                cleanText = rawLine.substring(1).trim();
            } else {
                level = 0; // Chapter (No hash)
            }

            // 2. Parse Title and Page Number (@pg)
            // Example: "Introduction to Tax @pg 5"
            const parts = cleanText.split('@pg');
            
            const title = parts[0].trim();
            // Store page number if it exists, else null
            const pdfPage = (parts.length > 1) ? parts[1].trim() : null;
            
            const id = generateId();

            // Helper to create node object
            const createNode = (t, p) => ({ id, title: t, pdfPage: p, desc: '', children: [] });

            // 3. Build Hierarchy
            if (level === 0) {
                // Chapter
                currentChap = createNode(title, pdfPage);
                newChapters.push(currentChap);
                currentL1 = null; 
                currentL2 = null;
            } else if (level === 1) {
                // Level 1
                if (currentChap) {
                    currentL1 = createNode(title, pdfPage);
                    currentChap.children.push(currentL1);
                    currentL2 = null;
                }
            } else if (level === 2) {
                // Level 2
                if (currentL1) {
                    currentL2 = createNode(title, pdfPage);
                    currentL1.children.push(currentL2);
                }
            } else if (level === 3) {
                // Level 3
                if (currentL2) {
                    const l3 = createNode(title, pdfPage);
                    currentL2.children.push(l3);
                }
            }
        });

        // Append new chapters to current subject
        currentSubject.chapters = [...currentSubject.chapters, ...newChapters];

        saveData(); 
        
        // Auto select newly imported
        if (newChapters.length > 0) {
            appState.activeChapterId = newChapters[0].id;
            if(newChapters[0].children.length > 0) appState.activeLevel1Id = newChapters[0].children[0].id;
        }

        renderInputView();
        
        // Reset Visualizer
        collapseAll();
        isTreeFullyExpanded = false;
        
        closeImportModal();
        alert('Import successful!');
    }

    // --- Notes Feature ---
    function openNotesModal(e, id) {
        if (e && e.stopPropagation) e.stopPropagation(); 
        currentNoteNodeId = id;
        const sub = getActiveSubject();
        const nodeData = findNodePath(sub.chapters, id);
        
        if(nodeData && nodeData.node) {
            const content = nodeData.node.notes || '';
            const textarea = document.getElementById('note-content');
            textarea.value = content;
            
            if(content.trim().length > 0) {
                setNoteMode('VIEW');
            } else {
                setNoteMode('EDIT');
            }

            document.getElementById('notes-modal').classList.add('open');
        }
    }

    function toggleNoteMode() {
        if (isNoteEditMode) {
            saveNotes(); 
        } else {
            setNoteMode('EDIT');
        }
    }

    function setNoteMode(mode) {
        const textarea = document.getElementById('note-content');
        const preview = document.getElementById('note-preview');
        const badge = document.getElementById('note-mode-badge');
        const btn = document.getElementById('btn-note-action');

        if (mode === 'EDIT') {
            isNoteEditMode = true;
            
            // Switch Panes
            textarea.classList.remove('hidden-pane');
            textarea.classList.add('active-pane');
            preview.classList.remove('active-pane');
            preview.classList.add('hidden-pane');
            
            // Update Badge
            badge.innerText = 'EDIT MODE';
            badge.className = 'mode-badge badge-edit';
            badge.style.backgroundColor = '#eff6ff';
            badge.style.color = '#1d4ed8';
            badge.style.borderColor = '#3b82f6';
            
            // --- UPDATED BUTTON FOR SAVE STATE ---
            btn.innerHTML = '‚úÖ';
            btn.title = "Save(Shift+Enter)";
            
            textarea.focus();
        } else {
            isNoteEditMode = false;
            
            // Render Preview
            const content = textarea.value;
            if (typeof marked !== 'undefined') {
                preview.innerHTML = marked.parse(content || '*No content*');
            } else {
                preview.innerHTML = `<p>${content || '<em>No content</em>'}</p>`;
            }

            // START AMENDMENT: Force New Tab & Stop PDF Interceptor
            // ============================================================
            const noteLinks = preview.querySelectorAll('a');
            noteLinks.forEach(link => {
                // 1. Force open in new tab
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
                
                // 2. Stop Propagation: Prevents the global "PDF Viewer" 
                // listener from catching this click and opening the iframe.
                link.onclick = (e) => e.stopPropagation(); 
            });

            // Switch Panes
            preview.classList.remove('hidden-pane');
            preview.classList.add('active-pane');
            textarea.classList.remove('active-pane');
            textarea.classList.add('hidden-pane');

            // Update Badge
            badge.innerText = 'VIEW MODE';
            badge.className = 'mode-badge badge-view';
            badge.style.backgroundColor = '#ecfdf5';
            badge.style.color = '#059669';
            badge.style.borderColor = '#10b981';

            // --- UPDATED BUTTON FOR EDIT STATE ---
            btn.innerHTML = 'üñäÔ∏è';
            btn.title = "Edit(Shift+Enter)";
        }
    }

    function closeNotesModal() {
        document.getElementById('notes-modal').classList.remove('open');
        currentNoteNodeId = null;
    }

    function saveNotes() {
        if(!currentNoteNodeId) return;
        const val = document.getElementById('note-content').value;
        const sub = getActiveSubject();
        const nodeData = findNodePath(sub.chapters, currentNoteNodeId);
        if(nodeData && nodeData.node) {
            nodeData.node.notes = val;
            saveData(); 
            renderVisualizer(); // Re-render to show bulb if logic changed
            setNoteMode('VIEW'); 
        }
    }

    function deleteCurrentNote() {
        if (!currentNoteNodeId) return;
        const sub = getActiveSubject();
        const nodeData = findNodePath(sub.chapters, currentNoteNodeId);
        
        if (nodeData && nodeData.node) {
            nodeData.node.notes = "";
            document.getElementById('note-content').value = "";
            document.getElementById('note-preview').innerHTML = "";
            saveData();
            renderVisualizer();
            setNoteMode('EDIT');
        }
    }

    // --- Drag Handlers (Input View) ---
    function handleDragStart(e, index, type) {
        dragSrcIndex = index;
        dragType = type;
        e.dataTransfer.effectAllowed = 'move';
        e.target.closest('.draggable-item').classList.add('dragging');
    }

    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function handleDragEnter(e) {
        e.target.closest('.draggable-item')?.classList.add('drag-over');
    }

    function handleDragLeave(e) {
        e.target.closest('.draggable-item')?.classList.remove('drag-over');
    }

    function handleDrop(e, index, type) {
        e.stopPropagation();
        const item = e.target.closest('.draggable-item');
        if (item) item.classList.remove('drag-over', 'dragging');

        if (dragSrcIndex === null || dragType !== type || dragSrcIndex === index) return false;

        const sub = getActiveSubject();

        if (type === 'chapter') {
            const items = [...sub.chapters];
            const [moved] = items.splice(dragSrcIndex, 1);
            items.splice(index, 0, moved);
            sub.chapters = items;
            saveData();
            renderChaptersList();
        } else if (type === 'level1') {
            const chap = getActiveChapter();
            if (chap) {
                const items = [...chap.children];
                const [moved] = items.splice(dragSrcIndex, 1);
                items.splice(index, 0, moved);
                chap.children = items;
                saveData();
                renderLevel1List();
            }
        }
        return false;
    }

    function handleDragEnd(e) {
        document.querySelectorAll('.draggable-item').forEach(el => el.classList.remove('dragging', 'drag-over'));
        dragSrcIndex = null;
        dragType = null;
    }

    // --- Tool Drag Logic (Note & Add) ---
    const noteTool = document.getElementById('draggable-note-tool');
    const addTool = document.getElementById('draggable-add-tool');

    noteTool.addEventListener('dragstart', (e) => {
        isDraggingNoteTool = true;
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('text/plain', 'note-tool');
    });
    
    addTool.addEventListener('dragstart', (e) => {
        isDraggingAddTool = true;
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('text/plain', 'add-tool');
    });
    
    const toolDragEnd = (e) => {
        isDraggingNoteTool = false;
        isDraggingAddTool = false;
        document.querySelectorAll('.node.note-drag-target').forEach(el => el.classList.remove('note-drag-target'));
        document.querySelectorAll('.node.add-drag-target').forEach(el => el.classList.remove('add-drag-target'));
    };

    noteTool.addEventListener('dragend', toolDragEnd);
    addTool.addEventListener('dragend', toolDragEnd);


    // --- Drag Handlers (Visualization View) ---
    function handleVisDragStart(e, id) {
        if(isDraggingNoteTool || isDraggingAddTool || isSelectionMode) {
             e.preventDefault(); 
             return; 
        }
        e.stopPropagation();
        visDragId = id;
        e.target.classList.add('dragging-vis');
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleVisDragOver(e, id) {
        e.preventDefault();
        e.stopPropagation();
        const targetNode = e.currentTarget;

        if(isDraggingNoteTool) {
            e.dataTransfer.dropEffect = 'copy';
            targetNode.classList.add('note-drag-target');
            return;
        }

        if(isDraggingAddTool) {
            e.dataTransfer.dropEffect = 'copy';
            targetNode.classList.add('add-drag-target');
            return;
        }

        if(visDragId === id) return; 
        targetNode.classList.add('drag-target');
    }

    function handleVisDragLeave(e) {
        const targetNode = e.currentTarget;
        targetNode.classList.remove('drag-target');
        targetNode.classList.remove('note-drag-target');
        targetNode.classList.remove('add-drag-target');
    }

    function handleVisDrop(e, targetId) {
        e.stopPropagation();
        e.currentTarget.classList.remove('drag-target');
        e.currentTarget.classList.remove('note-drag-target');
        e.currentTarget.classList.remove('add-drag-target');
        
        if(isDraggingNoteTool) {
            isDraggingNoteTool = false;
            openNotesModal(e, targetId);
            return;
        }

        if(isDraggingAddTool) {
            isDraggingAddTool = false;
            addNewChildNode(targetId);
            return;
        }

        const srcId = visDragId;
        visDragId = null;
        document.querySelector('.dragging-vis')?.classList.remove('dragging-vis');
        
        if(!srcId || srcId === targetId) return;

        moveNode(srcId, targetId);
    }

    // --- ADD CHILD VIA DRAG LOGIC ---
    function addNewChildNode(parentId) {
        const sub = getActiveSubject();
        const parentInfo = findNodePath(sub.chapters, parentId);
        
        if(!parentInfo) return; // Should not happen

        const parentNode = parentInfo.node;
        const parentDepth = parentInfo.path.length; // 0=Chapter, 1=Level1, 2=Level2
        
        // Determine what to add based on parent depth
        let newNode = null;
        let newActiveLevel1Id = null;
        let newActiveChapterId = appState.activeChapterId; // Default to current

        if (parentDepth === 0) {
            // Parent is Chapter -> Add Level 1
            const count = parentNode.children.length + 1;
            newNode = { id: generateId(), title: `${count}. New Tab`, desc: '', children: [] };
            parentNode.children.push(newNode);
            
            // Set pointers for navigation
            newActiveChapterId = parentNode.id;
            newActiveLevel1Id = newNode.id;

        } else if (parentDepth === 1) {
            // Parent is Level 1 -> Add Level 2 (Topic)
            const count = parentNode.children.length + 1;
            newNode = { id: generateId(), title: `${count}. Topic`, desc: '', children: [] };
            parentNode.children.push(newNode);
            
            // Pointers
            newActiveChapterId = parentInfo.path[0]; // Chapter ID
            newActiveLevel1Id = parentNode.id; // Level 1 ID

        } else if (parentDepth === 2) {
             // Parent is Level 2 -> Add Level 3 (Detail)
            const count = parentNode.children.length + 1;
            newNode = { id: generateId(), title: `${count}. Detail`, desc: '', children: [] };
            parentNode.children.push(newNode);
            
            // Pointers
            newActiveChapterId = parentInfo.path[0];
            newActiveLevel1Id = parentInfo.path[1];
        } else {
            alert("Max depth reached. Cannot add children to Level 3.");
            return;
        }

        // Expand parent to show new node
        appState.expandedNodes.delete(parentId);

        saveData();
        
        // Navigation Logic
        appState.activeChapterId = newActiveChapterId;
        appState.activeLevel1Id = newActiveLevel1Id;
        
        // Prepare to focus
        pendingFocusNodeId = newNode.id;

        // Switch to Data Entry
        switchView('input');
    }
    
    function findNodePath(arr, id, path = []) {
        for(let i=0; i<arr.length; i++) {
            if(arr[i].id === id) return { node: arr[i], parentArr: arr, index: i, path };
            if(arr[i].children) {
                const result = findNodePath(arr[i].children, id, [...path, arr[i].id]);
                if(result) return result;
            }
        }
        return null;
    }

// --- HELPER 1: Strip existing prefixes (Numbers or Letters) ---
    function cleanTitle(title) {
        return title.replace(/^([0-9]+|[A-Z]+)\.\s*/, '');
    }

    // --- HELPER 2: Apply correct numbering based on Depth ---
    function applyRenumbering(list, depthLevel) {
        list.forEach((node, idx) => {
            const clean = cleanTitle(node.title);
            let prefix = '';
            
            // Depth 1 = Level 1 (Numeric: 1. )
            // Depth 2 = Level 2 (Alpha: A. )
            // Depth 3 = Level 3 (Numeric: 1. )
            
            if (depthLevel === 1) { 
                 prefix = (idx + 1) + '.';
            } else if (depthLevel === 2) { 
                 prefix = String.fromCharCode(65 + idx) + '.';
            } else if (depthLevel === 3) { 
                 prefix = (idx + 1) + '.';
            } else {
                // Depth 0 (Chapters) or others -> Skip renumbering
                return; 
            }
            
            node.title = `${prefix} ${clean}`;
        });
    }

    // --- UPDATED: MOVE NODE WITH AUTO-RENUMBERING ---
    window.moveNode = function(srcId, targetId) {
        const sub = getActiveSubject();
        
        // 1. Locate Source and Target
        const srcInfo = findNodePath(sub.chapters, srcId);
        if(!srcInfo) return; 
        const targetInfo = findNodePath(sub.chapters, targetId);
        if(!targetInfo) return; 

        // Constraint: Can't move into own child
        if(targetInfo.path.includes(srcId)) {
            alert("Cannot move a node into its own child.");
            return;
        }
        // Constraint: Can't move into itself
        if (srcId === targetId) return;

        // 2. EXECUTE MOVE (Cut & Paste)
        const [movedNode] = srcInfo.parentArr.splice(srcInfo.index, 1);
        if(!targetInfo.node.children) targetInfo.node.children = [];
        targetInfo.node.children.push(movedNode);

        // 3. RENUMBER SOURCE LIST (The list it left)
        // srcInfo.path.length gives us the depth of the item *before* it moved
        // [] = Chapter (0), [id] = Level 1 (1), [id, id] = Level 2 (2)
        const srcDepth = srcInfo.path.length; 
        applyRenumbering(srcInfo.parentArr, srcDepth);

        // 4. RENUMBER TARGET LIST (The list it joined)
        // targetInfo.path gives us the depth of the *new parent*
        // So the children are at (parent depth + 1)
        const targetDepth = targetInfo.path.length + 1;
        applyRenumbering(targetInfo.node.children, targetDepth);

        // 5. Cleanup & Save
        appState.expandedNodes.delete(targetId); // Auto-expand target to show dropped item
        saveData(); 
        renderVisualizer();
        renderInputView(); 
    };


    // --- Renderers ---
    function renderInputView() {
        renderChaptersList();
        renderLevel1List();
        renderEditor();
    }

    function renderChaptersList() {
        const container = document.getElementById('chapters-list');
        container.innerHTML = '';
        const sub = getActiveSubject();
        
        if(!sub) return;

        sub.chapters.forEach((chap, index) => {
            const div = document.createElement('div');
            div.className = `chapter-item draggable-item ${chap.id === appState.activeChapterId ? 'active' : ''}`;
            div.draggable = true;
            
            // Drag Events
            div.ondragstart = (e) => handleDragStart(e, index, 'chapter');
            div.ondragover = handleDragOver;
            div.ondragenter = handleDragEnter;
            div.ondragleave = handleDragLeave;
            div.ondrop = (e) => handleDrop(e, index, 'chapter');
            div.ondragend = handleDragEnd;

            // Content
            div.innerHTML = `
                <div style="display:flex; align-items:center; flex:1;">
                    <span class="drag-handle">‚ãÆ‚ãÆ</span>
                    <span class="title-span" style="flex:1;">${chap.title || 'Untitled'}</span>
                </div>
                <button class="btn-icon">√ó</button>
            `;

            const titleSpan = div.querySelector('.title-span');
            titleSpan.title = "Double-click to rename";
            titleSpan.ondblclick = (e) => enableInlineEdit(e, chap.id, 'chapter');
            
            const btn = div.querySelector('.btn-icon');
            btn.onclick = (e) => deleteChapter(chap.id, e);

            div.onclick = (e) => {
                if(e.target.tagName === 'INPUT') return;
                appState.activeChapterId = chap.id;
                if (chap.children.length > 0) appState.activeLevel1Id = chap.children[0].id;
                else appState.activeLevel1Id = null;
                renderInputView();
            };
            container.appendChild(div);
        });
    }

    function renderLevel1List() {
        const container = document.getElementById('level1-list');
        container.innerHTML = '';
        
        const chap = getActiveChapter();
        if (!chap) { container.innerHTML = '<div class="empty-msg">No Chapter Selected</div>'; return; }
        if (chap.children.length === 0) { container.innerHTML = '<div class="empty-msg">No Level 1 Tabs. Click + to add.</div>'; return; }

        chap.children.forEach((l1, index) => {
            const div = document.createElement('div');
            div.className = `level1-item draggable-item ${l1.id === appState.activeLevel1Id ? 'active' : ''}`;
            div.draggable = true;

            // Drag Events
            div.ondragstart = (e) => handleDragStart(e, index, 'level1');
            div.ondragover = handleDragOver;
            div.ondragenter = handleDragEnter;
            div.ondragleave = handleDragLeave;
            div.ondrop = (e) => handleDrop(e, index, 'level1');
            div.ondragend = handleDragEnd;

            div.innerHTML = `
                <div style="display:flex; align-items:center; flex:1;">
                    <span class="drag-handle">‚ãÆ‚ãÆ</span>
                    <span class="title-span" style="flex:1;">${l1.title || 'Untitled'}</span>
                </div>
                <button class="btn-icon">√ó</button>
            `;

            const titleSpan = div.querySelector('.title-span');
            titleSpan.title = "Double-click to rename";
            titleSpan.ondblclick = (e) => enableInlineEdit(e, l1.id, 'level1');

            const btn = div.querySelector('.btn-icon');
            btn.onclick = (e) => deleteLevel1(l1.id, e);

            div.onclick = (e) => {
                if(e.target.tagName === 'INPUT') return;
                appState.activeLevel1Id = l1.id;
                renderInputView();
            };
            container.appendChild(div);
        });
    }
    
    function enableInlineEdit(event, id, type) {
        event.stopPropagation();
        const span = event.target;
        const currentText = span.innerText;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentText;
        input.className = 'inline-edit-input';
        input.setAttribute('autocomplete', 'off');
        span.replaceWith(input);
        input.focus();
        input.select(); 
        const save = () => {
            const newVal = input.value.trim() || currentText;
            if (type === 'chapter') {
                const sub = getActiveSubject();
                const node = sub.chapters.find(c => c.id === id);
                if(node) node.title = newVal;
                saveData(); renderChaptersList();
                if(appState.activeChapterId === id) renderEditor(); 
            } else if (type === 'level1') {
                const chap = getActiveChapter();
                const node = chap.children.find(l => l.id === id);
                if(node) node.title = newVal;
                saveData(); renderLevel1List();
                if(appState.activeLevel1Id === id) renderEditor();
            }
        };
        input.onblur = save;
        input.onkeydown = (e) => { if(e.key === 'Enter') input.blur(); };
        input.onclick = (e) => e.stopPropagation();
    }

    function renderEditor() {
        const container = document.getElementById('editor-area');
        const status = document.getElementById('editor-status');
        const chap = getActiveChapter();
        
        if(!chap) { container.innerHTML = ''; status.innerText = ''; return; }
        const l1 = getActiveLevel1();
        
        // --- CHAPTER CARD (Master Link Input is here) ---
        let html = `
            <div class="section-card" style="background:#f8fafc; border-color:#e2e8f0;">
                <div class="input-group">
                    <label class="input-label">Chapter Title</label>
                    <input class="text-input chapter-input" data-node-id="${chap.id}" autocomplete="off" type="text" value="${chap.title}" onchange="updateChapterTitle(this.value)" placeholder="Chapter Name">
                </div>
                
                <div class="input-group" style="margin-top: 0.8rem; margin-bottom:0;">
                    <label class="input-label">Link Address (Applies to all nodes)</label>
                    <input class="text-input link-input" autocomplete="off" type="text" value="${chap.link || ''}" onchange="updateChapterLink(this.value)" placeholder="https://...">
                </div>
            </div>
        `;

        if (!l1) { html += '<div class="empty-msg">Select or create a Level 1 tab to edit its content.</div>'; container.innerHTML = html; status.innerText = 'Editing Chapter Settings'; return; }
        status.innerText = `Editing: ${l1.title}`;

        // --- LEVEL 1 CARD (No Link Input) ---
        html += `
            <div class="section-card">
                <div class="input-group">
                    <label class="input-label">Level 1 Title</label>
                    <input class="text-input level-1-input" data-node-id="${l1.id}" autocomplete="off" type="text" value="${l1.title}" onchange="updateLevel1Title(this.value)">
                </div>
                <div class="input-group">
                    <label class="input-label">Description</label>
                    <input class="text-input desc-input" autocomplete="off" type="text" value="${l1.desc || ''}" onchange="updateLevel1Desc(this.value)">
                </div>
                <div style="margin-top:2rem; padding-top:1rem; border-top:1px solid #eee;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:1rem;">
                        <span class="input-label" style="margin:0;">Level 2 Items</span>
                        <button class="btn-add orange" onclick="addLevel2()">+ Add Level 2</button>
                    </div>
                    <div id="l2-container"></div>
                </div>
            </div>
        `;
        container.innerHTML = html;
        
        // --- CHILDREN (No Link Inputs) ---
        const l2Container = document.getElementById('l2-container');
        l1.children.forEach(l2 => {
            const blk = document.createElement('div');
            blk.className = 'level2-block';
            let l3Html = '';
            l2.children.forEach(l3 => {
                l3Html += `
                    <div class="level3-row">
                        <div style="flex:1; display:flex; flex-direction:column; gap:4px;">
                            <input class="text-input level-3-input" data-node-id="${l3.id}" autocomplete="off" style="padding:0.4rem; font-size:0.9rem;" value="${l3.title}" onchange="updateNodeTitle('${l3.id}', this.value)" placeholder="Level 3 Title">
                            <input class="text-input desc-input" autocomplete="off" style="padding:0.3rem; font-size:0.8rem;" value="${l3.desc || ''}" onchange="updateNodeDesc('${l3.id}', this.value)" placeholder="Description (Optional)">
                        </div>
                        <button class="btn-icon" onclick="deleteNode('${l3.id}', '${l2.id}')">√ó</button>
                    </div>
                `;
            });
            blk.innerHTML = `
                <div class="level2-header">
                    <div class="level2-title-row">
                        <input class="text-input level-2-input" data-node-id="${l2.id}" autocomplete="off" value="${l2.title}" onchange="updateNodeTitle('${l2.id}', this.value)" placeholder="Level 2 Title">
                        <button class="btn-icon" onclick="deleteNode('${l2.id}', '${l1.id}')">√ó</button>
                    </div>
                    <input class="text-input desc-input" autocomplete="off" value="${l2.desc || ''}" onchange="updateNodeDesc('${l2.id}', this.value)" placeholder="Level 2 Description (Optional)">
                </div>
                <div class="level3-list">
                    ${l3Html}
                    <button class="btn-add orange" style="background:#e0f2f1; color:#059669; margin-top:0.5rem;" onclick="addLevel3('${l2.id}')">+ L3</button>
                </div>
            `;
            l2Container.appendChild(blk);
        });
    }

    function updateChapterLink(val) {
        const chap = getActiveChapter();
        if(chap) {
            chap.link = val;
            saveData(); // Save to localStorage/Server
            // renderVisualizer(); // Optional: update tree immediately
        }
    }

    function addChapter() {
        const sub = getActiveSubject();
        const id = generateId();
        const nextNum = sub.chapters.length + 1;
        const newTitle = `Chapter ${nextNum}`;
        sub.chapters.push({ id, title: newTitle, desc:'', children: [] });
        appState.activeChapterId = id;
        appState.activeLevel1Id = null;
        saveData(); renderInputView();
    }
    function deleteChapter(id, e) {
        e.stopPropagation();
        if(!confirm('Delete this chapter?')) return;
        const sub = getActiveSubject();
        sub.chapters = sub.chapters.filter(c => c.id !== id);
        if(appState.activeChapterId === id) {
            appState.activeChapterId = sub.chapters.length > 0 ? sub.chapters[0].id : null;
            appState.activeLevel1Id = null;
        }
        saveData(); renderInputView();
    }
    function updateChapterTitle(val) { const c = getActiveChapter(); if(c) { c.title = val; saveData(); renderChaptersList(); } }
    function addLevel1() {
        const c = getActiveChapter();
        if(!c) return alert("Select a chapter first");
        const id = generateId();
        const nextNum = c.children.length + 1;
        const newTitle = `${nextNum}. New Tab`;
        c.children.push({ id, title: newTitle, desc:'', children:[] });
        appState.activeLevel1Id = id;
        saveData(); renderInputView();
    }
    function deleteLevel1(id, e) {
        e.stopPropagation();
        const c = getActiveChapter();
        c.children = c.children.filter(l => l.id !== id);
        if (appState.activeLevel1Id === id) appState.activeLevel1Id = null;
        saveData(); renderInputView();
    }
    function updateLevel1Title(val) { const l1 = getActiveLevel1(); if(l1) { l1.title = val; saveData(); renderLevel1List(); } }
    function updateLevel1Desc(val) { const l1 = getActiveLevel1(); if(l1) { l1.desc = val; saveData(); } }
    function addLevel2() {
        const l1 = getActiveLevel1();
        const nextNum = l1.children.length + 1;
        const newTitle = `${nextNum}. Topic`;
        l1.children.push({ id: generateId(), title: newTitle, desc:'', children: [] });
        saveData(); renderEditor();
    }
    function addLevel3(parentId) {
        const l1 = getActiveLevel1();
        const l2 = l1.children.find(n => n.id === parentId);
        if(l2) {
            const nextNum = l2.children.length + 1;
            const newTitle = `${nextNum}. Detail`;
            l2.children.push({ id: generateId(), title: newTitle, desc:'', children: [] });
            saveData(); renderEditor();
        }
    }
    function updateNodeTitle(id, val) {
        const l1 = getActiveLevel1();
        let n = l1.children.find(x => x.id === id);
        if(n) { n.title = val; saveData(); return; }
        l1.children.forEach(l2 => {
            let l3 = l2.children.find(x => x.id === id);
            if(l3) { l3.title = val; saveData(); }
        });
    }
    function updateNodeDesc(id, val) {
        const l1 = getActiveLevel1();
        let n = l1.children.find(x => x.id === id);
        if(n) { n.desc = val; saveData(); return; }
        l1.children.forEach(l2 => {
            let l3 = l2.children.find(x => x.id === id);
            if(l3) { l3.desc = val; saveData(); }
        });
    }
    function deleteNode(id, parentId) {
        const l1 = getActiveLevel1();
        if (l1.id === parentId) { l1.children = l1.children.filter(x => x.id !== id); }
        else { const l2 = l1.children.find(x => x.id === parentId); if(l2) { l2.children = l2.children.filter(x => x.id !== id); } }
        saveData(); renderEditor();
    }

    // --- Visualization & Collapse Logic ---
    function switchView(view) {
        document.querySelectorAll('.view-section').forEach(e => e.classList.remove('active-view'));
        document.querySelectorAll('.nav-tab').forEach(e => e.classList.remove('active'));
        if(view === 'input') {
            document.getElementById('input-view').classList.add('active-view');
            document.querySelectorAll('.nav-tab')[0].classList.add('active');
            renderInputView();
            
            // Check for pending focus from drag-add
            if(pendingFocusNodeId) {
                setTimeout(() => {
                    const input = document.querySelector(`input[data-node-id="${pendingFocusNodeId}"]`);
                    if(input) { input.focus(); input.select(); }
                    pendingFocusNodeId = null;
                }, 100);
            }
        } else {
            document.getElementById('result-view').classList.add('active-view');
            document.querySelectorAll('.nav-tab')[1].classList.add('active');
            renderVisualizer();
        }
    }

    // ZOOM LOGIC
    function zoomIn() {
        zoomLevel += 0.1;
        applyZoom();
    }
    function zoomOut() {
        if(zoomLevel > 0.2) zoomLevel -= 0.1;
        applyZoom();
    }
    function resetZoom() {
        zoomLevel = 1;
        applyZoom();
    }
    function applyZoom() {
        // Use standard 'zoom' property for better scroll handling in WebKit/Blink
        document.getElementById('result-container').style.zoom = zoomLevel;
    }

    // TOGGLE TREE
    function toggleTreeState() {
        const btn = document.getElementById('tree-toggle-btn');
        const label = document.getElementById('toggle-label-text');
        
        if (isTreeFullyExpanded) {
            collapseAll();
            isTreeFullyExpanded = false;
            
            btn.classList.remove('state-expanded');
            btn.classList.add('state-collapsed');
            label.innerText = "Expand All";
        } else {
            expandAll();
            isTreeFullyExpanded = true;
            
            btn.classList.remove('state-collapsed');
            btn.classList.add('state-expanded');
            label.innerText = "Collapse All";
        }
    }

    function expandAll() { 
        appState.expandedNodes.clear(); 
        renderVisualizer(); 
    }
    
    function collapseAll() { 
        const allIds = []; 
        const sub = getActiveSubject();
        sub.chapters.forEach(chap => collectIds(chap, allIds)); 
        allIds.forEach(id => appState.expandedNodes.add(id)); 
        renderVisualizer(); 
    }
    
    function collapseRecursive(node) {
        appState.expandedNodes.add(node.id);
        if (node.children) node.children.forEach(child => collapseRecursive(child));
    }
    function collectIds(node, list) {
        if(node.children && node.children.length > 0) { list.push(node.id); node.children.forEach(child => collectIds(child, list)); }
    }

    // --- SELECTION & MULTI-DELETE ---
    function toggleSelectionMode() {
        isSelectionMode = !isSelectionMode;
        const btn = document.getElementById('select-mode-btn');
        const delWrapper = document.getElementById('delete-selected-wrapper');
        
        if(isSelectionMode) {
            btn.classList.add('selection-mode-active');
            delWrapper.style.display = 'block';
        } else {
            btn.classList.remove('selection-mode-active');
            delWrapper.style.display = 'none';
            selectedNodeIds.clear(); // Clear selection when exiting mode
        }
        renderVisualizer();
    }

    function handleNodeClick(e, node) {
        e.stopPropagation(); // Stop bubble

        if(isSelectionMode) {
            if(selectedNodeIds.has(node.id)) {
                selectedNodeIds.delete(node.id);
            } else {
                selectedNodeIds.add(node.id);
            }
            renderVisualizer();
            return;
        }

        // Standard behavior: Toggle Collapse
        if (node.children && node.children.length > 0) {
            if(appState.expandedNodes.has(node.id)) { appState.expandedNodes.delete(node.id); } 
            else { collapseRecursive(node); } 
            renderVisualizer(); 
        }
    }

    function deleteSelectedNodes() {
        if(selectedNodeIds.size === 0) return alert("No nodes selected.");
        if(!confirm(`Delete ${selectedNodeIds.size} selected items? (Children included)`)) return;

        const sub = getActiveSubject();
        
        // Recursive Filter Function
        const filterNodes = (nodes) => {
            return nodes.filter(node => {
                // If this node is selected for deletion, remove it (filter out)
                if(selectedNodeIds.has(node.id)) return false;
                
                // Otherwise, keep it, but check its children
                if(node.children) {
                    node.children = filterNodes(node.children);
                }
                return true;
            });
        };

        sub.chapters = filterNodes(sub.chapters);
        
        // Cleanup selection
        selectedNodeIds.clear();
        isSelectionMode = false;
        document.getElementById('select-mode-btn').classList.remove('selection-mode-active');
        document.getElementById('delete-selected-wrapper').style.display = 'none';

        saveData();
        renderVisualizer();
        renderInputView(); // Update input view as well
    }
    
    function renderVisualizer() {
        const container = document.getElementById('result-container');
        container.innerHTML = '';
        const sub = getActiveSubject();
        
        sub.chapters.forEach(chap => {
            const treeRoot = document.createElement('div');
            treeRoot.className = 'tree-ltr';
            treeRoot.appendChild(buildTreeHTML(chap, 0));
            container.appendChild(treeRoot);
        });
    }
    
    function buildTreeHTML(node, level) {
        const li = document.createElement('li');
        const card = document.createElement('div');
        const hasChildren = node.children && node.children.length > 0;
        const isCollapsed = appState.expandedNodes.has(node.id); 
        
        // Selection State
        const isSelected = selectedNodeIds.has(node.id);

        card.className = `node level-${Math.min(level, 3)} ${isCollapsed ? 'collapsed' : ''} ${isSelected ? 'node-selected' : ''}`;
        
        // Notes Logic
        const hasNotes = node.notes && node.notes.trim().length > 0;
        const bulbClass = hasNotes ? 'bulb-btn has-notes' : 'bulb-btn';
        const bulb = `<button class="${bulbClass}" onclick="openNotesModal(event, '${node.id}')" title="View/Edit Notes">‚ú¶</button>`;

        card.innerHTML = `<h4>${node.title || 'Untitled'}</h4>${node.desc ? `<p>${node.desc}</p>` : ''}${hasChildren ? `<span class="expander">${isCollapsed ? '+' : '-'}</span>` : ''}${bulb}`;
        
        // Add Drag Attributes (Disable dragging if in Selection Mode to avoid conflict)
        if(!isSelectionMode) {
            card.draggable = true;
            card.ondragstart = (e) => handleVisDragStart(e, node.id);
            card.ondragover = (e) => handleVisDragOver(e, node.id);
            card.ondragleave = (e) => handleVisDragLeave(e);
            card.ondrop = (e) => handleVisDrop(e, node.id);
        }

        // Click Handler (Toggle or Select)
        card.onclick = (e) => handleNodeClick(e, node);

        li.appendChild(card);
        if (hasChildren && !appState.expandedNodes.has(node.id)) {
            const ul = document.createElement('ul');
            node.children.forEach(child => { ul.appendChild(buildTreeHTML(child, level + 1)); });
            li.appendChild(ul);
        }
        if (level === 0) { const rootUl = document.createElement('ul'); rootUl.style.paddingLeft = '0'; rootUl.appendChild(li); return rootUl; }
        return li;
    }

    loadData();

    // --- SECURITY: WIPE ON CLOSE ---
    window.addEventListener('beforeunload', (e) => {
        e.preventDefault();
        e.returnValue = ''; 
    });

    window.addEventListener('pagehide', () => {
        localStorage.removeItem(STORAGE_KEY);
    });

</script>

<script type="module">
    // 1. Import Firebase libraries
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // 2. Project Credentials
    const firebaseConfig = {
        apiKey: "AIzaSyAqwOPonkGFYLpj7FULmUJeY76t_Rm9cuM",
        authDomain: "ca-notes143.firebaseapp.com",
        projectId: "ca-notes143",
        storageBucket: "ca-notes143.firebasestorage.app",
        messagingSenderId: "519846107572",
        appId: "1:519846107572:web:42747869d5aa5896a47ae1",
        measurementId: "G-Q4LQ77ZDM6"
    };

    // 3. Initialize connection
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // --- REFS ---
    const metaRef = doc(db, "personal_notes", "ca_hq_meta"); 
    const oldLegacyRef = doc(db, "personal_notes", "ca_final_pad");

    // --- SMART LOAD LOGIC ---
    window.addEventListener('DOMContentLoaded', async () => {
        const overlay = document.getElementById('loading-overlay');
        
        try {
            // STEP A: Try to load the Meta Index
            const metaSnap = await getDoc(metaRef);
            
            let finalSubjects = [];
            let finalActiveId = null;

            if (metaSnap.exists()) {
                console.log("Loading Split Architecture...");
                const metaData = metaSnap.data();
                finalActiveId = metaData.activeSubjectId;
                const subjectList = metaData.subjectList || [];

                // STEP B: Fetch all subject documents
                const promises = subjectList.map(subItem => {
                    const subRef = doc(db, "ca_hq_subjects", subItem.id);
                    return getDoc(subRef);
                });

                const snapshots = await Promise.all(promises);

                snapshots.forEach(snap => {
                    if(snap.exists()) {
                        const rawData = snap.data();
                        
                        // *** HYBRID LOADER ***
                        if (rawData.subjectData && typeof rawData.subjectData === 'string') {
                            finalSubjects.push(JSON.parse(rawData.subjectData));
                        } else {
                            finalSubjects.push(rawData);
                        }
                    }
                });

                if(finalSubjects.length === 0) finalSubjects = appState.subjects; 

            } else {
                // STEP C: Legacy Fallback
                const oldSnap = await getDoc(oldLegacyRef);
                if (oldSnap.exists()) {
                    const cloudJson = oldSnap.data().hierarchyData;
                    const loadedData = JSON.parse(cloudJson);
                    finalSubjects = loadedData.subjects;
                    finalActiveId = loadedData.activeSubjectId;
                    alert("Legacy Data Loaded. Please click 'Save' to update format.");
                }
            }

            // STEP D: Apply to AppState
            if(finalSubjects.length > 0) appState.subjects = finalSubjects;
            
            // Validate Active ID
            const targetSubject = appState.subjects.find(s => s.id === finalActiveId);
            if(targetSubject) {
                appState.activeSubjectId = finalActiveId;
                // Pointer Fix
                if (targetSubject.chapters.length > 0) {
                    appState.activeChapterId = targetSubject.chapters[0].id;
                    if (targetSubject.chapters[0].children.length > 0) {
                        appState.activeLevel1Id = targetSubject.chapters[0].children[0].id;
                    }
                }
            } else {
                appState.activeSubjectId = appState.subjects[0].id;
            }

            // STEP E: Refresh UI
            const selector = document.getElementById('subject-selector');
            if (selector) {
                selector.innerHTML = ''; 
                appState.subjects.forEach(sub => {
                    const opt = document.createElement('option');
                    opt.value = sub.id;
                    opt.textContent = sub.name; 
                    if(sub.id === appState.activeSubjectId) opt.selected = true;
                    selector.appendChild(opt);
                });
            }

            // STEP F: FORCE COLLAPSE (The Fix)
            // We verify that the main app functions exist before calling them
            if (typeof collapseAll === 'function') {
                appState.expandedNodes = new Set(); // Clear state
                collapseAll(); // Force collapse logic
                
                // Update the Toggle Button UI to match
                const btn = document.getElementById('tree-toggle-btn');
                const label = document.getElementById('toggle-label-text');
                if(btn) {
                     btn.classList.remove('state-expanded');
                     btn.classList.add('state-collapsed');
                     if(label) label.innerText = "Expand All";
                }
                // Reset global flag
                if(typeof isTreeFullyExpanded !== 'undefined') isTreeFullyExpanded = false;
            }

            setTimeout(() => {
                const visBtn = document.querySelectorAll('.nav-tab')[1];
                const dataBtn = document.querySelectorAll('.nav-tab')[0];
                if (visBtn && dataBtn) { visBtn.click(); setTimeout(() => { dataBtn.click(); }, 100); }
            }, 100);

        } catch (e) {
            console.error("Sync Error:", e);
            alert("Error loading data: " + e.message);
        } finally {
            setTimeout(() => { if (overlay) overlay.style.display = 'none'; }, 500);
        }
    });

    // --- SAVE LOGIC ---
    window.saveToCloud = async function() {
        closeExportChoiceModal();
        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.style.display = 'flex';
        loadingOverlay.querySelector('p').innerText = "Saving compact files...";

        try {
            let sizeReport = "";

            // 1. Size Check
            for (let sub of appState.subjects) {
                const subJson = JSON.stringify(sub);
                const sizeInBytes = new Blob([subJson]).size;
                const sizeInMB = parseFloat((sizeInBytes / (1024 * 1024)).toFixed(3));
                
                sizeReport += `‚Ä¢ ${sub.name}: ${sizeInMB} MB\n`;

                if (sizeInMB > 0.98) throw new Error(`Subject "${sub.name}" is too large (${sizeInMB} MB). Limit is 1.00 MB.`);
            }

            // 2. Meta Data
            const metaData = {
                activeSubjectId: appState.activeSubjectId,
                subjectList: appState.subjects.map(s => ({ id: s.id, name: s.name })),
                lastUpdated: new Date().toLocaleString(),
                version: 'v3_compact'
            };

            const savePromises = [];
            savePromises.push(setDoc(metaRef, metaData));

            // 3. Save
            appState.subjects.forEach(sub => {
                const subRef = doc(db, "ca_hq_subjects", sub.id);
                const compactData = JSON.stringify(sub);
                savePromises.push(setDoc(subRef, { subjectData: compactData }));
            });

            await Promise.all(savePromises);
            
            alert(`‚úÖ Saved Successfully!\n\nStorage Report:\n${sizeReport}\n(Limit per file: 1.00 MB)`);

        } catch (e) {
            console.error(e);
            alert("Save Failed: " + e.message);
        } finally {
            loadingOverlay.style.display = 'none';
            loadingOverlay.querySelector('p').innerText = "Syncing CA Notes...";
        }
    };
</script>

<script>
(function() {
    // 1. INTELLIGENT DETECTION (Fixes the Windows Issue)
    // We check for "Android" or "iPhone/iPad" specifically.
    // We also check if screen width is small (like a phone).
    const isAndroidOrIOS = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isSmallScreen = window.innerWidth < 900;
    
    // Only turn on Mobile Mode if it's actually a mobile device
    if (isAndroidOrIOS || isSmallScreen) {
        document.body.classList.add('is-mobile');
    } else {
        // If Desktop Windows, stop here! Don't run the patch.
        return; 
    }

    // // 1. Force Mobile Mode
    // document.body.classList.add('is-mobile');

    
    // Global State for Mobile Actions
    window.mobileState = {
        srcId: null,      // ID of item being moved
        mode: null,       // 'list-move' or 'vis-move'
        tool: null        // 'note', 'add', 'move'
    };

    // ============================================================
    // PART A: VISUALIZATION WINDOW (Tree View)
    // ============================================================

    // 1. Inject the "Move Tool" (Hand Icon) into the Toolbar
    setTimeout(() => {
        const toolbar = document.querySelector('.result-toolbar');
        if(toolbar && !document.getElementById('mobile-move-tool')) {
            // Create wrapper for the button
            const div = document.createElement('div');
            div.className = 'btn-wrapper';
            div.innerHTML = `
                <button id="mobile-move-tool" class="toggle-icon-btn" onclick="toggleVisTool('move')" style="opacity: 0.7;">üñêüèª</button>
                <div class="toggle-label">Move Node</div>
            `;
            // Insert it at the top of the toolbar
            toolbar.insertBefore(div, toolbar.firstElementChild);
        }
        
        // Disable Dragging on the existing Note/Add tools so they work as tap buttons
        const noteTool = document.getElementById('draggable-note-tool');
        const addTool = document.getElementById('draggable-add-tool');
        if(noteTool) {
            noteTool.draggable = false;
            noteTool.onclick = (e) => { e.preventDefault(); toggleVisTool('note'); };
        }
        if(addTool) {
            addTool.draggable = false;
            addTool.onclick = (e) => { e.preventDefault(); toggleVisTool('add'); };
        }
    }, 500);

    // 2. Tool Toggle Logic
    window.toggleVisTool = function(toolName) {
        const state = window.mobileState;
        const btnMove = document.getElementById('mobile-move-tool');
        const btnNote = document.getElementById('draggable-note-tool');
        const btnAdd = document.getElementById('draggable-add-tool');

        // Reset all buttons visual state
        if(btnMove) btnMove.style.color = '#64748b';
        if(btnMove) btnMove.style.opacity = 0.7;
        if(btnMove) btnMove.style.borderColor = 'white';
        if(btnNote) btnNote.classList.remove('mobile-tool-active');
        if(btnAdd) btnAdd.classList.remove('mobile-tool-active');

        // Toggle Off if clicking same tool
        if (state.tool === toolName) {
            state.tool = null;
            state.srcId = null; // Clear any pending move selection
            renderVisualizer(); // Clear green highlight
            return;
        }

        // Activate Tool
        state.tool = toolName;
        
        if(toolName === 'move') {
            if(btnMove) { btnMove.style.opacity = '1'; btnMove.style.color = '#2563eb'; btnMove.style.borderColor = '#CBCBCB'; }
        } else if (toolName === 'note') {
            if(btnNote) btnNote.classList.add('mobile-tool-active');
        } else if (toolName === 'add') {
            if(btnAdd) btnAdd.classList.add('mobile-tool-active');
        }
    };

    // 3. Intercept Node Clicks in the Tree
    const originalHandleNodeClick = window.handleNodeClick;

    window.handleNodeClick = function(e, node) {
        const state = window.mobileState;
        
        // If no tool active, do normal collapse/expand
        if (!state.tool) {
            if(originalHandleNodeClick) originalHandleNodeClick(e, node);
            return;
        }

        e.stopPropagation(); // Stop click from bubbling

        // --- HAND TOOL (MOVE) LOGIC ---
        if (state.tool === 'move') {
            
            // Step 1: Select Source
            if (!state.srcId) {
                state.srcId = node.id;
                renderVisualizer(); // Re-render to show green highlight on source
                return;
            }

            // Step 2: Select Target (Action!)
            const targetId = node.id;
            const srcId = state.srcId;

            if (srcId === targetId) {
                // Cancel if clicked self
                state.srcId = null;
                renderVisualizer();
                return;
            }

            // Execute the Move
            executeVisMove(srcId, targetId);
            
            // Reset
            state.srcId = null;
            // Optional: Keep tool active for more moves? Or turn off? 
            // Let's keep it active for batch moving.
            renderVisualizer();
            return;
        }

        // --- NOTE TOOL LOGIC ---
        if (state.tool === 'note') {
            openNotesModal(e, node.id);
        }

        // --- ADD TOOL LOGIC ---
        if (state.tool === 'add') {
            addNewChildNode(node.id);
        }
    };

    // 4. UPDATED Logic: Route Mobile Hand Tool to Main Logic
    window.executeVisMove = function(srcId, targetId) {
        // We simply call the main moveNode function, which now handles
        // all the validation, moving, and AUTO-RENUMBERING.
        moveNode(srcId, targetId);
    };

    // ============================================================
    // PART B: DATA ENTRY WINDOW (List View) - Kept for backup
    // ============================================================
    
    // Override Renderers to show Move Buttons
    window.renderChaptersList = function() {
        const container = document.getElementById('chapters-list');
        container.innerHTML = '';
        const sub = getActiveSubject();
        if(!sub) return;

        sub.chapters.forEach((chap) => {
            const div = document.createElement('div');
            const isActive = chap.id === appState.activeChapterId;
            const isMoving = (window.mobileState.mode === 'list-move' && window.mobileState.srcId === chap.id);
            
            div.className = `chapter-item ${isActive ? 'active' : ''} ${isMoving ? 'move-active' : ''}`;
            div.innerHTML = `
                <div style="display:flex; align-items:center; flex:1;">
                    <button class="btn-mobile-move" ontouchstart="event.stopPropagation();" onclick="list_handleMove('${chap.id}', 'chapter', event)">${isMoving ? '‚¨á' : '‚áÖ'}</button>
                    <span class="title-span" style="flex:1; margin-left:12px; padding: 10px 0;" onclick="list_select('${chap.id}', 'chapter')">${chap.title || 'Untitled'}</span>
                </div>
                <button class="btn-icon" onclick="deleteChapter('${chap.id}', event)">√ó</button>
            `;
            container.appendChild(div);
        });
    };

    window.renderLevel1List = function() {
        const container = document.getElementById('level1-list');
        container.innerHTML = '';
        const chap = getActiveChapter();
        if (!chap) { container.innerHTML = '<div class="empty-msg">No Chapter</div>'; return; }

        chap.children.forEach((l1) => {
            const div = document.createElement('div');
            const isActive = l1.id === appState.activeLevel1Id;
            const isMoving = (window.mobileState.mode === 'list-move' && window.mobileState.srcId === l1.id);
            
            div.className = `level1-item ${isActive ? 'active' : ''} ${isMoving ? 'move-active' : ''}`;
            div.innerHTML = `
                <div style="display:flex; align-items:center; flex:1;">
                    <button class="btn-mobile-move" ontouchstart="event.stopPropagation();" onclick="list_handleMove('${l1.id}', 'level1', event)">${isMoving ? '‚¨á' : '‚áÖ'}</button>
                    <span class="title-span" style="flex:1; margin-left:12px; padding: 10px 0;" onclick="list_select('${l1.id}', 'level1')">${l1.title || 'Untitled'}</span>
                </div>
                <button class="btn-icon" onclick="deleteLevel1('${l1.id}', event)">√ó</button>
            `;
            container.appendChild(div);
        });
    };

    window.list_select = function(id, type) {
        if(window.mobileState.mode === 'list-move' && window.mobileState.srcId) return;
        if(type === 'chapter') {
            appState.activeChapterId = id;
            const c = getActiveChapter();
            appState.activeLevel1Id = (c && c.children.length > 0) ? c.children[0].id : null;
        } else {
            appState.activeLevel1Id = id;
        }
        renderInputView();
    };

    window.list_handleMove = function(targetId, type, e) {
        if(e) { e.preventDefault(); e.stopPropagation(); }
        const state = window.mobileState;

        if (!state.srcId) {
            state.srcId = targetId;
            state.mode = 'list-move';
            renderInputView(); return;
        }
        if (state.srcId === targetId) {
            state.srcId = null; state.mode = null;
            renderInputView(); return;
        }

        let list = (type === 'chapter') ? getActiveSubject().chapters : getActiveChapter().children;
        const srcIndex = list.findIndex(x => x.id === state.srcId);
        const tgtIndex = list.findIndex(x => x.id === targetId);

        if (srcIndex > -1 && tgtIndex > -1) {
            const [movedItem] = list.splice(srcIndex, 1);
            list.splice(tgtIndex, 0, movedItem);
            saveData();
        }
        state.srcId = null; state.mode = null;
        renderInputView();
    };

    // Helper: Override buildTreeHTML to add visual indicator for moving
    const originalBuildTreeHTML = window.buildTreeHTML; // Note: You might need to expose this in main script if wrapped
    // Since buildTreeHTML is likely global, we override it carefully
    
    // We actually just rely on CSS injection for the visualization highlight
    // The handleNodeClick logic above handles the rest.

    // Force Initial Render
    setTimeout(renderInputView, 100);

})();
</script>

<style>
    /* 1. Mobile Tool Active State (Blue Glow for Toolbar) */
    .mobile-tool-active {
        border-color: #2563eb !important;
        color: white !important; transform: scale(1.1);
        box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
    }
    
    /* 2. List View - Arrow Buttons (Default: HIDDEN on Desktop) */
    .btn-mobile-move {
        /* --- VISUAL STYLES (From your code) --- */
        background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 4px;
        min-width: 44px; height: 44px; font-size: 1.4rem;
        align-items: center; justify-content: center;
        color: #64748b; cursor: pointer; margin-right: 5px; z-index: 10;
        
        /* --- LOGIC CHANGE: Hide by default for Desktop --- */
        display: none; 
    }

    /* 3. List View - Drag Dots (Default: VISIBLE on Desktop) */
    .drag-handle {
        display: inline-block;
        cursor: grab;
        color: #cbd5e1;
        font-size: 1.2rem;
        padding: 0 8px;
    }

    /* --- 4. MOBILE OVERRIDE (Triggered by JS) --- */
    /* When on mobile, FLIP the visibility */
    body.is-mobile .btn-mobile-move {
        display: flex; /* Show Arrows */
    }
    body.is-mobile .drag-handle {
        display: none; /* Hide Dots */
    }

    /* --- 5. ACTIVE MOVE STATES (Green Highlights) --- */
    
    /* A. List View Item Active */
    .move-active {
        background-color: #dcfce7 !important;
        border: 2px dashed #16a34a !important;
    }
    
    /* Force Arrow to show if we are currently moving it, even if logic says otherwise */
    .move-active .btn-mobile-move { 
        display: flex !important; 
        background: #16a34a; 
        color: white; 
        border-color: #15803d; 
    }

    /* B. Visualization Tree Node Active (The Green Box) */
    .node.move-active {
        background-color: #dcfce7 !important;
        border-color: #16a34a !important;
        box-shadow: 0 0 0 4px rgba(22, 163, 74, 0.4) !important;
        transform: scale(1.05);
        z-index: 100;
    }
</style>
<script>
    // Helper to highlight the source node in tree view
    setInterval(() => {
        if(window.mobileState && window.mobileState.tool === 'move' && window.mobileState.srcId) {
            // Find all nodes
            document.querySelectorAll('.node').forEach(n => {
                // We don't have ID on the DOM element by default. 
                // We need to match title? No, unreliable.
                // FIX: Let's assume the click handler works, but we want visual feedback.
                // We can't easily highlight without re-rendering the tree with IDs.
            });
            
            // Actually, let's just make the clicked node turn green via the click event instantly
            // The re-render might wash it away.
        }
    }, 1000);
    
    // BETTER FIX: Override buildTreeHTML to include ID in the DOM
    window.buildTreeHTML = function(node, level) {
        const li = document.createElement('li');
        const card = document.createElement('div');
        const hasChild = node.children && node.children.length > 0;
        const isCollapsed = appState.expandedNodes.has(node.id);
        const hasNotes = node.notes && node.notes.trim().length > 0;
        
        // CHECK IF MOVING
        const isSource = (window.mobileState && window.mobileState.srcId === node.id);
        
        card.id = 'node-' + node.id; // Add ID to DOM
        card.className = `node level-${Math.min(level,3)} ${isCollapsed?'collapsed':''} ${selectedNodeIds.has(node.id)?'node-selected':''} ${isSource ? 'move-active' : ''}`;
        
        // Add Hand Icon if in Move Mode? No, toolbar controls it.
        
        card.innerHTML = `<h4>${node.title}</h4>${node.desc?`<p>${node.desc}</p>`:''}${hasChild?`<span class="expander">${isCollapsed?'+':'-'}</span>`:''}<button class="bulb-btn ${hasNotes?'has-notes':''}" onclick="openNotesModal(event,'${node.id}')">‚ú¶</button>`;
        
        // Desktop Drag (still needed for laptop users)
        card.draggable = true;
        card.ondragstart=(e)=>handleVisDragStart(e,node.id);
        card.ondragover=(e)=>handleVisDragOver(e,node.id);
        card.ondragleave=(e)=>handleVisDragLeave(e);
        card.ondrop=(e)=>handleVisDrop(e,node.id);
        
        card.onclick = (e) => handleNodeClick(e, node);
        
        li.appendChild(card);
        if(hasChild && !isCollapsed) {
            const ul = document.createElement('ul');
            node.children.forEach(child => ul.appendChild(buildTreeHTML(child, level+1)));
            li.appendChild(ul);
        }
        if(level===0) { const ul=document.createElement('ul'); ul.style.paddingLeft='0'; ul.appendChild(li); return ul; }
        return li;
    };
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<style>
    /* --- 1. VISUAL STYLES --- */
    .node {
        transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), 
                    opacity 0.3s ease, 
                    filter 0.3s ease,
                    box-shadow 0.2s ease,
                    border-color 0.2s ease; /* Smooth border transition */
        position: relative;
        z-index: 1; 
    }

    /* Highlight Glow (Amber) - BORDER ONLY */
    .node.path-glow {
        border-color: #f59e0b !important;
        /* background-color: REMOVED; */
        box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.3) !important;
        z-index: 1000 !important;
    }

    /* Focus Mode (Dimming) */
    /* Logic changed: Dim everything that is NOT an active part of the path */
    body.is-focused .node:not(.path-active-node) {
        opacity: 0.1;
        filter: grayscale(100%);
    }
    
    /* Dim inactive lines */
    body.is-focused .tree-ltr li::before,
    body.is-focused .tree-ltr li::after {
        opacity: 0.05;
    }
    
    /* Keep active path lines visible */
    body.is-focused .tree-ltr li.path-active-li::before,
    body.is-focused .tree-ltr li.path-active-li::after {
        opacity: 1 !important;
        border-color: #cbd5e1; 
    }

    /* --- 2. TOOLTIP STYLES --- */
    #tree-tooltip {
        position: fixed;
        background: rgba(255, 255, 255, 0.98); 
        color: #1e293b; 
        padding: 6px 12px;
        border-radius: 6px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 12px;
        font-weight: 700; 
        pointer-events: none; 
        z-index: 9999;
        white-space: nowrap;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); 
        border: 1px solid #e2e8f0; 
        display: none; 
        backdrop-filter: blur(4px);
        transform: translate(-50%, -100%); 
    }
    #tree-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -4px;
        border-width: 4px;
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.98) transparent transparent transparent;
    }

    .tt-level-0 { color: #4338ca; } 
    .tt-level-1 { color: #be185d; } 
    .tt-level-2 { color: #c2410c; } 
    .tt-level-3 { color: #047857; } 
    .tt-sep { color: #94a3b8; margin: 0 6px; font-weight: 400; }

    /* --- 3. TOOLBAR UI --- */
    .left-toolbar {
        position: absolute; top: 20px; left: 20px; z-index: 100;
        pointer-events: none; display: flex; flex-direction: column; 
        align-items: center; gap: 12px;
    }
    .left-toolbar button { pointer-events: auto; }

    #trace-sub-options {
        display: none; flex-direction: column; gap: 12px; align-items: center;
    }

    /* --- BUTTON STYLES --- */
    #btn-trace-toggle {
        background-color: #ffffff !important; 
        border: 2px solid #ffffff !important;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        width: 45px; height: 45px;
        border-radius: 50%;
        display: flex; align-items: center; justify-content: center;
        transition: all 0.2s;
        font-size: 1.5rem;
        color: #64748b !important;
        filter: grayscale(0%);
        opacity: 0.7;
    }
    #btn-trace-toggle:hover { 
        transform: scale(1.1); 
        opacity: 1; 
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        color: #334155;
    }
    #btn-trace-toggle.path-mode-active {
        color: #f59e0b !important; 
        filter: grayscale(0%) !important;
        opacity: 1 !important;
        border-color: #CBCBCB !important; /* Your specific grey border */
    }

    .btn-sub-opt {
        width: 38px; height: 38px;
        border-radius: 50%;
        background-color: #ffffff !important;
        border: 2px solid #ffffff !important;
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        cursor: pointer;
        font-size: 1.1rem;
        display: flex; align-items: center; justify-content: center;
        transition: all 0.2s;
        color: #64748b !important;
        filter: grayscale(100%);
        opacity: 0.7;
    }
    .btn-sub-opt:hover { transform: scale(1.1); opacity: 1; }

    .btn-sub-opt.btn-on {
        filter: grayscale(0%) !important;
        opacity: 1 !important;
        border-color: #CBCBCB !important;
    }
    
    .btn-sub-opt.btn-on.icon-text { color: #f59e0b !important; }
    .btn-sub-opt.btn-on.icon-glow { color: #f59e0b !important; } 
    .btn-sub-opt.btn-on.icon-align { color: #10b981 !important; }
    .btn-sub-opt.btn-on.icon-focus { color: #8b5cf6 !important; }

</style>

<div id="tree-tooltip"></div>

<script>
    const traceState = {
        master: false, 
        text: false,      
        highlight: false, 
        align: false,     
        focus: false      
    };

    // --- TOGGLE FUNCTIONS ---
    window.toggleMasterTrace = function() {
        traceState.master = !traceState.master;
        const masterBtn = document.getElementById('btn-trace-toggle');
        const optionsDiv = document.getElementById('trace-sub-options');

        if (traceState.master) {
            masterBtn.classList.add('path-mode-active');
            optionsDiv.style.display = 'flex';
        } else {
            masterBtn.classList.remove('path-mode-active');
            optionsDiv.style.display = 'none';
            resetView(); 
        }
    };

    function toggleSubState(key, btn) {
        traceState[key] = !traceState[key];
        
        if(traceState[key]) {
            btn.classList.add('btn-on');
        } else {
            btn.classList.remove('btn-on');
            if(key === 'text') hideTooltip();
            if(key === 'highlight') document.querySelectorAll('.path-glow').forEach(el => el.classList.remove('path-glow'));
            if(key === 'align') document.querySelectorAll('.node').forEach(el => el.style.transform = '');
            if(key === 'focus') document.body.classList.remove('is-focused');
        }
    }

    // --- VISUAL LOGIC ---
    const tooltipEl = document.getElementById('tree-tooltip');

    window.updateTooltipPos = function(x, y) {
        tooltipEl.style.left = x + 'px';
        tooltipEl.style.top = (y - 35) + 'px'; 
    };

    window.hideTooltip = function() { tooltipEl.style.display = 'none'; };

    window.resetView = function() {
        document.body.classList.remove('is-focused');
        document.querySelectorAll('.path-active-node').forEach(el => el.classList.remove('path-active-node')); // Clean internal class
        document.querySelectorAll('.path-glow').forEach(el => el.classList.remove('path-glow'));
        document.querySelectorAll('.path-active-li').forEach(el => el.classList.remove('path-active-li'));
        document.querySelectorAll('.node').forEach(el => el.style.transform = '');
        hideTooltip();
    };

    // *** HOVER HANDLER ***
    window.handleHover = function(e, hoveredCard) {
        if (!traceState.master) return; 

        const isHovering = e.type === 'mouseenter';
        
        if (!isHovering) {
            resetView();
            return;
        }

        // Apply Focus Mode globally
        if (traceState.focus) document.body.classList.add('is-focused');

        let targetCenterY = 0;
        if (traceState.align) {
            const rect = hoveredCard.getBoundingClientRect();
            targetCenterY = rect.top + (rect.height / 2);
        }

        // --- NEW: HANDLE DESCENDANTS (Look Downwards) ---
        // Find the LI wrapping the hovered card
        const parentLi = hoveredCard.closest('li');
        
        if (parentLi) {
            // 1. Highlight the hovered card itself explicitly
            hoveredCard.classList.add('path-active-node');
            
            // 2. If focused, find ALL open/visible child LIs and keep their lines visible
            if (traceState.focus) {
                parentLi.querySelectorAll('li').forEach(childLi => {
                    childLi.classList.add('path-active-li');
                });
            }

            // 3. Find ALL open/visible child Nodes and keep them visible
            parentLi.querySelectorAll('.node').forEach(childNode => {
                childNode.classList.add('path-active-node');
            });
        }

        // --- EXISTING: HANDLE ANCESTORS (Look Upwards) ---
        let li = parentLi;
        let pathData = []; 

        const getLevel = (node) => {
            if(node.classList.contains('level-0')) return 0;
            if(node.classList.contains('level-1')) return 1;
            if(node.classList.contains('level-2')) return 2;
            if(node.classList.contains('level-3')) return 3;
            return 0;
        }

        while (li) {
            // Keep lines visible if Focusing
            if(traceState.focus) li.classList.add('path-active-li');
            
            let node = li.querySelector(':scope > .node');
            if (node) {
                // Keep node visible
                node.classList.add('path-active-node');

                // A. Visual Highlight (Orange Border)
                if (traceState.highlight) node.classList.add('path-glow');

                // B. Alignment
                if (traceState.align && node !== hoveredCard) {
                    const ancRect = node.getBoundingClientRect();
                    const ancCenterY = ancRect.top + (ancRect.height / 2);
                    const diff = targetCenterY - ancCenterY;
                    node.style.transform = `translateY(${diff}px)`;
                }

                pathData.unshift({
                    title: node.querySelector('h4').innerText,
                    level: getLevel(node)
                });
            }
            li = li.parentElement ? li.parentElement.closest('li') : null;
        }

        // Tooltip
        if (traceState.text) {
            const html = pathData.map(item => 
                `<span class="tt-level-${item.level}">${item.title}</span>`
            ).join('<span class="tt-sep">/</span>');
            
            tooltipEl.innerHTML = html;
            tooltipEl.style.display = 'block';
            updateTooltipPos(e.clientX, e.clientY);
        }
    };

    window.trackMouse = function(e) {
        if (!traceState.master || !traceState.text) return;
        if(tooltipEl.style.display === 'block') {
            updateTooltipPos(e.clientX, e.clientY);
        }
    };

    // --- TOOLBAR INJECTION ---
    (function initToolbar() {
        const view = document.getElementById('result-view');
        if (!view) return;

        let leftBar = document.querySelector('.left-toolbar');
        if (!leftBar) {
            leftBar = document.createElement('div');
            leftBar.className = 'left-toolbar';
            view.appendChild(leftBar);
        }

        if (!document.getElementById('btn-trace-toggle')) {
            const masterWrap = document.createElement('div');
            masterWrap.className = 'btn-wrapper';
            masterWrap.innerHTML = `
                <button id="btn-trace-toggle" class="toggle-icon-btn" onclick="toggleMasterTrace()">üëáüèª</button>
                <div class="toggle-label" style="left: 55px; right: auto;">Trace Mode</div>
            `;
            leftBar.appendChild(masterWrap);

            const optsDiv = document.createElement('div');
            optsDiv.id = 'trace-sub-options';
            optsDiv.innerHTML = `
                <div class="btn-wrapper">
                    <button class="btn-sub-opt icon-text" onclick="toggleSubState('text', this)">üìÖ</button>
                    <div class="toggle-label" style="left: 45px; right: auto;">[T]ext</div>
                </div>
                <div class="btn-wrapper">
                    <button class="btn-sub-opt icon-glow" onclick="toggleSubState('highlight', this)">‚ú®</button>
                    <div class="toggle-label" style="left: 45px; right: auto;">[H]ighlight</div>
                </div>
                <div class="btn-wrapper">
                    <button class="btn-sub-opt icon-align" onclick="toggleSubState('align', this)">üîó</button>
                    <div class="toggle-label" style="left: 45px; right: auto;">[A]lign <br> Hold Ctrl to lock alignment</div>
                </div>
                <div class="btn-wrapper">
                    <button class="btn-sub-opt icon-focus" onclick="toggleSubState('focus', this)">‚ùÑÔ∏è</button>
                    <div class="toggle-label" style="left: 45px; right: auto;">[F]ocus</div>
                </div>
            `;
            leftBar.appendChild(optsDiv);
        }
    })();

    // --- BUILDER OVERRIDE ---
    window.buildTreeHTML = function(node, level) {
        const li = document.createElement('li');
        const card = document.createElement('div');
        const hasChild = node.children && node.children.length > 0;
        const isCollapsed = appState.expandedNodes.has(node.id);
        const hasNotes = node.notes && node.notes.trim().length > 0;
        
        card.id = 'node-' + node.id;
        card.className = `node level-${Math.min(level,3)} ${isCollapsed?'collapsed':''} ${selectedNodeIds.has(node.id)?'node-selected':''}`;
        
        card.onmouseenter = (e) => handleHover(e, card);
        card.onmouseleave = (e) => handleHover(e, card);
        card.onmousemove  = (e) => trackMouse(e);

        const expander = hasChild ? `<span class="expander">${isCollapsed?'+':'-'}</span>` : '';
        const bulb = `<button class="bulb-btn ${hasNotes?'has-notes':''}" onclick="openNotesModal(event,'${node.id}')">‚ú¶</button>`;
        const desc = node.desc ? `<p>${node.desc}</p>` : '';
        
        card.innerHTML = `<h4>${node.title}</h4>${desc}${expander}${bulb}`;
        
        card.draggable = true;
        card.ondragstart = (e) => handleVisDragStart(e, node.id);
        card.ondragover = (e) => handleVisDragOver(e, node.id);
        card.ondragleave = (e) => handleVisDragLeave(e);
        card.ondrop = (e) => handleVisDrop(e, node.id);
        card.onclick = (e) => handleNodeClick(e, node);
        
        li.appendChild(card);

        if(hasChild && !isCollapsed) {
            const ul = document.createElement('ul');
            node.children.forEach(child => ul.appendChild(buildTreeHTML(child, level+1)));
            li.appendChild(ul);
        }
        
        if(level === 0) {
            const ul = document.createElement('ul');
            ul.style.paddingLeft = '0';
            ul.appendChild(li);
            return ul;
        }
        return li;
    };

    if(typeof renderVisualizer === 'function') renderVisualizer();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<style>
    /* 1. Floating Container */
    .vis-search-wrapper {
        position: fixed;        
        bottom: 30px;           
        right: 30px;            
        z-index: 9999;          
        
        /* HIDDEN BY DEFAULT (Controlled by JS) */
        display: none;          
        
        align-items: center;
        justify-content: center; 
        
        background: white; 
        border-radius: 50px;    
        padding: 0; 
        
        box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
        border: 1px solid #e2e8f0;
        
        /* Perfect Circle Dimensions */
        width: 40px; 
        height: 40px; 
        
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
    }

    /* Expand on Hover or Focus */
    .vis-search-wrapper:hover,
    .vis-search-wrapper.active {
        width: 240px; 
        border-color: #4f46e5;
        box-shadow: 0 8px 25px rgba(79, 70, 229, 0.15);
        justify-content: flex-start; 
        padding-left: 15px; 
    }

    /* 2. Search Input */
    .vis-search-input {
        border: none;
        outline: none;
        font-family: 'Segoe UI', sans-serif;
        font-size: 14px;
        color: #334155;
        width: 0; /* Collapsed */
        padding: 0;
        background: transparent;
        cursor: text; 
        opacity: 0; 
        transition: all 0.3s ease; 
    }
    
    .vis-search-wrapper:hover .vis-search-input,
    .vis-search-wrapper.active .vis-search-input,
    .vis-search-input:focus {
        width: 100%;
        opacity: 1;
        margin-right: 5px; 
    }

    /* 3. Search Icon - TRANSPARENT & CENTERED */
    .vis-search-btn {
        background: transparent !important; 
        color: #4f46e5 !important;          
        border: none;
        cursor: pointer;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex; align-items: center; justify-content: center;
        flex-shrink: 0; 
        font-size: 1.2rem; 
        line-height: 1;    
        transition: transform 0.2s;
        margin: 0; 
        padding: 0;
    }
    .vis-search-btn:hover { transform: scale(1.1); } 
    
    /* 4. CLEAR BUTTON */
    .vis-clear-btn {
        position: absolute; 
        right: 45px; 
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.8rem;
        color: #94a3b8; 
        display: none; 
        cursor: pointer;
        border: none;
        background: transparent;
        padding: 4px;
    }
    .vis-clear-btn:hover { color: #ef4444; }

    /* 5. SEARCH HIGHLIGHT STYLES (No Opacity Dimming needed anymore) */
    .node.search-match {
        border-color: #ec4899 !important; 
        box-shadow: 0 0 0 4px rgba(236, 72, 153, 0.4) !important;
        background-color: #fff1f2 !important;
        z-index: 100;
    }
    .node.search-path {
        border-color: #94a3b8; 
    }
</style>
<script>
    // --- SEARCH STATE ---
    window.searchMatches = new Set(); 
    window.searchPathNodes = new Set(); 
    window.isSearchActive = false; // Flag to control filtering

    // --- 1. INJECT FLOATING SEARCH ---
    (function injectSearchBar() {
        if (document.getElementById('vis-search-wrapper')) return;

        const div = document.createElement('div');
        div.id = 'vis-search-wrapper';
        div.className = 'vis-search-wrapper';
        
        div.onmousedown = (e) => e.stopPropagation();
        div.onclick = () => document.getElementById('vis-search-input').focus();

        div.innerHTML = `
            <input type="text" id="vis-search-input" class="vis-search-input" 
                   placeholder="Search..." 
                   onkeyup="checkSearchInput()" 
                   onkeydown="if(event.key==='Enter') performVisSearch()">
            <button id="vis-search-clear" class="vis-clear-btn" 
                    onclick="clearVisSearch()" title="Clear">‚úñ</button>
            <button class="vis-search-btn" onclick="performVisSearch()">üîç</button>
        `;
        document.body.appendChild(div);
    })();

    // --- 2. VISIBILITY LOGIC ---
    const originalSwitchView = window.switchView;
    window.switchView = function(view) {
        if (typeof originalSwitchView === 'function') originalSwitchView(view);
        const searchWrapper = document.getElementById('vis-search-wrapper');
        if (searchWrapper) {
            searchWrapper.style.display = (view === 'result') ? 'flex' : 'none';
        }
    };
    
    setTimeout(() => {
        const searchWrapper = document.getElementById('vis-search-wrapper');
        const isResultView = document.getElementById('result-view')?.classList.contains('active-view');
        if(searchWrapper && isResultView) searchWrapper.style.display = 'flex';
    }, 500);

    window.checkSearchInput = function() {
        const input = document.getElementById('vis-search-input');
        const wrapper = document.getElementById('vis-search-wrapper');
        const clearBtn = document.getElementById('vis-search-clear');
        if (input.value.trim().length > 0) {
            wrapper.classList.add('active');
            clearBtn.style.display = 'block';
        } else {
            wrapper.classList.remove('active');
            clearBtn.style.display = 'none';
        }
    }

    // --- 3. SEARCH EXECUTION ---
    window.performVisSearch = function() {
        const input = document.getElementById('vis-search-input');
        const term = input.value.toLowerCase().trim();

        if (!term) { clearVisSearch(); return; }

        window.searchMatches.clear();
        window.searchPathNodes.clear();

        const subject = appState.subjects.find(s => s.id === appState.activeSubjectId);
        if (!subject || !subject.chapters) return;

        let matchCount = 0;

        function traverseAndSearch(node, path) {
            const title = (node.title || '').toLowerCase();
            const desc = (node.desc || '').toLowerCase();
            const notes = (node.notes || '').toLowerCase();
            
            if (title.includes(term) || desc.includes(term) || notes.includes(term)) {
                window.searchMatches.add(node.id);
                matchCount++;
                // Mark all ancestors as path nodes so they render
                path.forEach(pid => window.searchPathNodes.add(pid));
            }
            if (node.children) {
                const newPath = [...path, node.id];
                node.children.forEach(child => traverseAndSearch(child, newPath));
            }
        }

        subject.chapters.forEach(chap => traverseAndSearch(chap, []));

        if (matchCount === 0) { alert("No matches found"); return; }

        // Enable Filter Mode
        window.isSearchActive = true; 
        document.body.classList.add('is-search-active');
        
        // Re-render tree (This triggers the filtering logic in buildTreeHTML)
        renderVisualizer();
        
        setTimeout(() => {
            const firstMatch = document.querySelector('.node.search-match');
            if(firstMatch) firstMatch.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
        }, 500);
    };

    window.clearVisSearch = function() {
        const input = document.getElementById('vis-search-input');
        const wrapper = document.getElementById('vis-search-wrapper');
        const clearBtn = document.getElementById('vis-search-clear');
        
        if(input) input.value = '';
        wrapper.classList.remove('active');
        clearBtn.style.display = 'none';
        
        // Disable Filter Mode
        window.isSearchActive = false;
        document.body.classList.remove('is-search-active');
        window.searchMatches.clear();
        window.searchPathNodes.clear();
        
        renderVisualizer();
    };

    // --- 4. FILTERING BUILDER ---
    window.buildTreeHTML = function(node, level) {
        // --- FILTER LOGIC START ---
        // If search is active, SKIP this node if it's not a match or part of the path
        if (window.isSearchActive) {
            const isMatch = window.searchMatches.has(node.id);
            const isPath = window.searchPathNodes.has(node.id);
            if (!isMatch && !isPath) return document.createDocumentFragment(); // Return empty (Don't Render)
        }
        // --- FILTER LOGIC END ---

        const li = document.createElement('li');
        const card = document.createElement('div');
        const hasChild = node.children && node.children.length > 0;
        
        // If filtering, force expansion so we see the results
        const isCollapsed = window.isSearchActive ? false : appState.expandedNodes.has(node.id);
        const hasNotes = node.notes && node.notes.trim().length > 0;
        
        card.id = 'node-' + node.id;
        let cssClasses = `node level-${Math.min(level,3)} ${isCollapsed?'collapsed':''} ${selectedNodeIds.has(node.id)?'node-selected':''}`;
        
        if (window.searchMatches.has(node.id)) cssClasses += ' search-match';
        else if (window.searchPathNodes.has(node.id)) cssClasses += ' search-path';
        
        card.className = cssClasses;

        // Re-attach Listeners
        if(typeof handleHover === 'function') {
            card.onmouseenter = (e) => handleHover(e, card);
            card.onmouseleave = (e) => handleHover(e, card);
        }
        if(typeof trackMouse === 'function') card.onmousemove = (e) => trackMouse(e);
        
        const expander = hasChild ? `<span class="expander">${isCollapsed?'+':'-'}</span>` : '';
        const bulb = `<button class="bulb-btn ${hasNotes?'has-notes':''}" onclick="openNotesModal(event,'${node.id}')">‚ú¶</button>`;
        const desc = node.desc ? `<p>${node.desc}</p>` : '';
        
        card.innerHTML = `<h4>${node.title}</h4>${desc}${expander}${bulb}`;
        
        card.draggable = true;
        card.ondragstart = (e) => handleVisDragStart(e, node.id);
        card.ondragover = (e) => handleVisDragOver(e, node.id);
        card.ondragleave = (e) => handleVisDragLeave(e);
        card.ondrop = (e) => handleVisDrop(e, node.id);
        card.onclick = (e) => handleNodeClick(e, node);
        
        li.appendChild(card);
        
        // Render Children (Recursively)
        if(hasChild && !isCollapsed) {
            const ul = document.createElement('ul');
            let childCount = 0;
            
            node.children.forEach(child => {
                const childNode = buildTreeHTML(child, level+1);
                // Check if the child returned actual content (wasn't filtered out)
                if(childNode && (childNode.childNodes.length > 0 || childNode.nodeType === Node.ELEMENT_NODE)) {
                    ul.appendChild(childNode);
                    childCount++;
                }
            });
            
            // Only append UL if it actually has visible children
            if(childCount > 0) li.appendChild(ul);
        }
        
        if(level === 0) {
            const ul = document.createElement('ul');
            ul.style.paddingLeft = '0';
            ul.appendChild(li);
            return ul;
        }
        return li;
    };

    if(typeof renderVisualizer === 'function') renderVisualizer();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
    // --- COLUMN RESIZING LOGIC ---
    (function enableResizing() {
        const createResizer = (resizerId, targetColId) => {
            const resizer = document.getElementById(resizerId);
            const targetCol = document.getElementById(targetColId);
            
            // Safety check: If elements don't exist, stop silently (don't break app)
            if (!resizer || !targetCol) return;

            let x = 0;
            let w = 0;

            const mouseDownHandler = (e) => {
                x = e.clientX;
                const styles = window.getComputedStyle(targetCol);
                w = parseInt(styles.width, 10);

                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
                
                resizer.classList.add('resizing');
                document.body.classList.add('resizing');
            };

            const mouseMoveHandler = (e) => {
                const dx = e.clientX - x;
                // Minimum width constraint (150px)
                if (w + dx > 150) {
                    targetCol.style.width = `${w + dx}px`;
                }
            };

            const mouseUpHandler = () => {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
                
                resizer.classList.remove('resizing');
                document.body.classList.remove('resizing');
            };

            resizer.addEventListener('mousedown', mouseDownHandler);
        };

        // Initialize Resizers safely
        // Ensure DOM is ready before running
        setTimeout(() => {
            createResizer('resizer-1', 'col-chapters');
            createResizer('resizer-2', 'col-level1');
        }, 500);
    })();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
    // --- INTERCEPT LINKS TO OPEN IN MOZILLA CUSTOM VIEWER ---
    document.addEventListener('click', function(e) {
        // 1. Check if the clicked element (or its parent) is a link <a>
        const link = e.target.closest('a');
        
        // ADD THIS: && !link.href.startsWith('blob:')
        if (link && link.href && !link.href.startsWith('javascript:') && !link.href.startsWith('#') && !link.href.startsWith('blob:')) {
            
            // 3. Prevent standard browser navigation
            e.preventDefault();
            e.stopPropagation();

            // 4. Route the URL to your existing "openSmartPdf" function
            // This uses the same Mozilla viewer overlay used for your page redirects
            if (typeof window.openSmartPdf === 'function') {
                window.openSmartPdf(link.href);
            } else {
                // Fallback (only if the viewer isn't loaded yet)
                window.open(link.href, '_blank');
            }
        }
    });
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<style>
    /* Badge Style Positioning - Top Right Edge */
    .branch-actions-wrapper {
        position: absolute;
        top: -12px;
        right: -8px;
        display: flex;
        gap: 4px;
        z-index: 20; 
    }

    .btn-branch-action {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        border: 1px solid #cbd5e1;
        cursor: pointer;
        font-size: 0.75rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.2s;
        padding: 0;
        line-height: 1;
    }

    .btn-branch-action:hover {
        transform: scale(1.15);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        z-index: 25;
    }

    .btn-branch-expand { color: #059669; border-color: #86efac; background: #ecfdf5; }
    .btn-branch-collapse { color: #dc2626; border-color: #fca5a5; background: #fef2f2; }
</style>

<script>

(function() {

    // 1. STATE INITIALIZATION

    appState.isolationMode = false;

    appState.validIsolatedIds = new Set();



    // 2. HELPER: Calculate which nodes to show in Isolation Mode

    function updateIsolationMap() {

        const sub = getActiveSubject();

        const validIds = new Set();

       

        selectedNodeIds.forEach(selId => {

            // A. Find path to root (Ancestors + Self)

            const pathData = findNodePath(sub.chapters, selId);

            if (!pathData) return;



            // Add Ancestors

            pathData.path.forEach(pId => validIds.add(pId));

            // Add Self

            validIds.add(selId);



            // B. Add All Descendants (Recursive)

            const addDescendants = (node) => {

                if (node.children) {

                    node.children.forEach(child => {

                        validIds.add(child.id);

                        addDescendants(child);

                    });

                }

            };

            addDescendants(pathData.node);

        });



        appState.validIsolatedIds = validIds;

    }



    // 3. HELPER: Scroll Anchoring

    function runAnchorAction(actionFn) {

        const anchorEl = document.querySelector('.node-selected');

        const viewport = document.getElementById('result-viewport');

        let prevRect = null;

        if (anchorEl && viewport) prevRect = anchorEl.getBoundingClientRect();

       

        actionFn();



        if (anchorEl && prevRect && viewport) {

            const newAnchorEl = document.getElementById(anchorEl.id);

            if (newAnchorEl) {

                const newRect = newAnchorEl.getBoundingClientRect();

                viewport.scrollTop += (newRect.top - prevRect.top);

                viewport.scrollLeft += (newRect.left - prevRect.left);

            }

        }

    }



    // 4. OVERRIDE: Toggle Tree State (With Isolation Logic)

    window.toggleTreeState = function() {

        const selectBtn = document.getElementById('select-mode-btn');

        const btn = document.getElementById('tree-toggle-btn');

        const label = document.getElementById('toggle-label-text');

       

        const isSelectActive = selectBtn && selectBtn.classList.contains('selection-mode-active');



        // --- A. SELECTION MODE LOGIC ---

        if (isSelectActive) {

            if (typeof selectedNodeIds === 'undefined' || selectedNodeIds.size === 0) {

                alert("Select Mode is Active, but no nodes are selected.\n\nClick on nodes to select them.");

                return;

            }



            runAnchorAction(() => {

                const sub = getActiveSubject();

                const firstId = selectedNodeIds.values().next().value;

                const isFirstCollapsed = appState.expandedNodes.has(firstId);



                if (isFirstCollapsed) {

                    // --- ACTION: EXPAND & ISOLATE ---

                    updateIsolationMap(); // Calculate paths

                    appState.isolationMode = true; // Enable Filter



                    // Expand Selected Nodes

                    const expandRecursive = (node) => {

                        appState.expandedNodes.delete(node.id);

                        if(node.children) node.children.forEach(expandRecursive);

                    };

                    selectedNodeIds.forEach(id => {

                        const data = findNodePath(sub.chapters, id);

                        if(data && data.node) expandRecursive(data.node);

                    });



                    btn.style.opacity = "1"; // Visual Feedback

                } else {

                    // --- ACTION: COLLAPSE & SHOW ALL ---

                    appState.isolationMode = false; // Disable Filter

                    appState.validIsolatedIds.clear();



                    // Collapse Selected Nodes

                    const collapseRecursive = (node) => {

                        if(node.children && node.children.length > 0) {

                            appState.expandedNodes.add(node.id);

                            node.children.forEach(collapseRecursive);

                        }

                    };

                    selectedNodeIds.forEach(id => {

                        const data = findNodePath(sub.chapters, id);

                        if(data && data.node) collapseRecursive(data.node);

                    });



                    btn.style.opacity = "0.7";

                }

               

                saveData();

                renderVisualizer();

            });

            return;

        }



        // --- B. GLOBAL LOGIC (Standard Behavior) ---

        // Force isolation off when using global toggle

        appState.isolationMode = false;



        if (isTreeFullyExpanded) {

            collapseAll();

            isTreeFullyExpanded = false;

            btn.classList.remove('state-expanded');

            btn.classList.add('state-collapsed');

            label.innerText = "Expand All";

        } else {

            expandAll();

            isTreeFullyExpanded = true;

            btn.classList.remove('state-collapsed');

            btn.classList.add('state-expanded');

            label.innerText = "Collapse All";

        }

    };



    // 5. OVERRIDE: Build Tree HTML (Adds Filter Logic)

    window.buildTreeHTML = function(node, level) {

        // --- FILTER CHECK ---

        // If Isolation Mode is ON, skip nodes that are not in the valid set

        if (appState.isolationMode && !appState.validIsolatedIds.has(node.id)) {

            return document.createDocumentFragment(); // Return empty (Hidden)

        }

       

        // (Preserve Search Filter if active)

        if (window.isSearchActive) {

            const isMatch = window.searchMatches.has(node.id);

            const isPath = window.searchPathNodes.has(node.id);

            if (!isMatch && !isPath) return document.createDocumentFragment();

        }

        // --------------------



        const li = document.createElement('li');

        const card = document.createElement('div');

        const hasChild = node.children && node.children.length > 0;

       

        // Force expansion if it's the selected node in isolation mode (optional UX preference)

        const isCollapsed = appState.expandedNodes.has(node.id);

        const hasNotes = node.notes && node.notes.trim().length > 0;

       

        // CSS Classes

        let cssClasses = `node level-${Math.min(level,3)} ${isCollapsed?'collapsed':''} ${selectedNodeIds.has(node.id)?'node-selected':''}`;

        if (window.searchMatches && window.searchMatches.has(node.id)) cssClasses += ' search-match';

        else if (window.searchPathNodes && window.searchPathNodes.has(node.id)) cssClasses += ' search-path';

       

        card.id = 'node-' + node.id;

        card.className = cssClasses;



        // Events

        if(typeof handleHover === 'function') {

            card.onmouseenter = (e) => handleHover(e, card);

            card.onmouseleave = (e) => handleHover(e, card);

        }

        if(typeof trackMouse === 'function') card.onmousemove = (e) => trackMouse(e);

       

        // Content

        const expander = hasChild ? `<span class="expander">${isCollapsed?'+':'-'}</span>` : '';

        const bulb = `<button class="bulb-btn ${hasNotes?'has-notes':''}" onclick="openNotesModal(event,'${node.id}')">‚ú¶</button>`;

        const desc = node.desc ? `<p>${node.desc}</p>` : '';

       

        card.innerHTML = `<h4>${node.title}</h4>${desc}${expander}${bulb}`;

       

        card.draggable = true;

        card.ondragstart = (e) => handleVisDragStart(e, node.id);

        card.ondragover = (e) => handleVisDragOver(e, node.id);

        card.ondragleave = (e) => handleVisDragLeave(e);

        card.ondrop = (e) => handleVisDrop(e, node.id);

        card.onclick = (e) => handleNodeClick(e, node);

       

        li.appendChild(card);

       

        // Children

        if(hasChild && !isCollapsed) {

            const ul = document.createElement('ul');

            let childCount = 0;

            node.children.forEach(child => {

                const childNode = buildTreeHTML(child, level+1);

                // Only append if it returned a valid node (wasn't filtered)

                if(childNode && (childNode.childNodes.length > 0 || childNode.nodeType === Node.ELEMENT_NODE)) {

                    ul.appendChild(childNode);

                    childCount++;

                }

            });

            if(childCount > 0) li.appendChild(ul);

        }

       

        if(level === 0) {

            const ul = document.createElement('ul');

            ul.style.paddingLeft = '0';

            ul.appendChild(li);

            return ul;

        }

        return li;

    };



    // 6. UI Update (Button Labels)

    const originalRender = window.renderVisualizer;

    window.renderVisualizer = function() {

        if(originalRender) originalRender();



        const selectBtn = document.getElementById('select-mode-btn');

        const isSelectActive = selectBtn && selectBtn.classList.contains('selection-mode-active');

        const toggleLabel = document.getElementById('toggle-label-text');



        if (isSelectActive && selectedNodeIds.size > 0) {

            // Check state of first selected node to determine label

            const firstId = selectedNodeIds.values().next().value;

            const isCollapsed = appState.expandedNodes.has(firstId);

            // Dynamic Label

            if (isCollapsed) {

                 toggleLabel.innerText = "Focus & Expand"; // Hints at the new behavior

            } else {

                 toggleLabel.innerText = "Reset View";

            }

        }

    };



})();

</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
/**
 * FEATURE UPDATE: Double-Click Chapter to Focus & Visualize
 * ---------------------------------------------------------
 * 1. Double-clicking a Chapter in Input View jumps to Result View.
 * 2. Result View filters to show ONLY that chapter.
 * 3. A "Show All" button appears to reset the view.
 * 4. UPDATE: Clicking "Show All" collapses the focused chapter.
 */

(function() {
    // 1. Initialize State
    appState.focusedChapterId = null;

    // 2. Override: renderChaptersList
    window.renderChaptersList = function() {
        const container = document.getElementById('chapters-list');
        container.innerHTML = '';
        const sub = getActiveSubject();
        
        if(!sub) return;

        sub.chapters.forEach((chap, index) => {
            const div = document.createElement('div');
            
            // 1. Calculate Moving State
            const isActive = chap.id === appState.activeChapterId;
            const isMoving = (window.mobileState && window.mobileState.mode === 'list-move' && window.mobileState.srcId === chap.id);

            div.className = `chapter-item draggable-item ${isActive ? 'active' : ''} ${isMoving ? 'move-active' : ''}`;
            div.draggable = true;
            
            // Drag Events
            div.ondragstart = (e) => handleDragStart(e, index, 'chapter');
            div.ondragover = handleDragOver;
            div.ondragenter = handleDragEnter;
            div.ondragleave = handleDragLeave;
            div.ondrop = (e) => handleDrop(e, index, 'chapter');
            div.ondragend = handleDragEnd;

            // Double Click
            div.ondblclick = (e) => {
                e.stopPropagation();
                focusOnChapterInVis(chap.id);
            };

            // Single Click
            div.onclick = (e) => {
                if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return; 
                appState.activeChapterId = chap.id;
                if (chap.children.length > 0) appState.activeLevel1Id = chap.children[0].id;
                else appState.activeLevel1Id = null;
                renderInputView();
            };

            // HTML Content: Includes BOTH Arrow and Dots
            // CSS will automatically decide which one to show based on the device
            div.innerHTML = `
                <div style="display:flex; align-items:center; flex:1;"> 
                    
                    <button class="btn-mobile-move" 
                        ontouchstart="event.stopPropagation();" 
                        onclick="list_handleMove('${chap.id}', 'chapter', event)">
                        ${isMoving ? '‚¨á' : '‚áÖ'}
                    </button>

                    <span class="drag-handle" style="margin-left: 5px;">‚ãÆ‚ãÆ</span>

                    <span class="title-span" style="flex:1; margin-left:8px;">${chap.title || 'Untitled'}</span>
                </div>
                <button class="btn-icon" onclick="deleteChapter('${chap.id}', event)">√ó</button>
            `;
            
            container.appendChild(div);
        });
    };
    // 3. Focus Logic (Entry)
    window.focusOnChapterInVis = function(id) {
        appState.focusedChapterId = id;
        appState.activeChapterId = id; // Sync selection
        
        // Auto-expand the target chapter so you can see inside immediately
        appState.expandedNodes.delete(id); 
        
        switchView('result');
        renderVisualizer(); 
    };

    // 4. Exit Logic (Updated)
    window.exitFocusMode = function() {
        // If there was a focused chapter, COLLAPSE it now
        if (appState.focusedChapterId) {
            appState.expandedNodes.add(appState.focusedChapterId);
        }

        // Clear focus and re-render full list
        appState.focusedChapterId = null;
        renderVisualizer();
    };

    // 5. Override: renderVisualizer
    window.renderVisualizer = function() {
        const container = document.getElementById('result-container');
        container.innerHTML = '';
        const sub = getActiveSubject();
        
        // --- FILTER LOGIC ---
        let chaptersToRender = sub.chapters;
        
        // If a specific chapter is focused, filter the list
        if (appState.focusedChapterId) {
            const target = sub.chapters.find(c => c.id === appState.focusedChapterId);
            if(target) chaptersToRender = [target];
        }

        // --- RENDER LOOP ---
        chaptersToRender.forEach(chap => {
            const treeRoot = document.createElement('div');
            treeRoot.className = 'tree-ltr';
            const treeContent = buildTreeHTML(chap, 0);
            
            // Render if valid content exists
            if (treeContent && (treeContent.childNodes.length > 0 || treeContent.nodeType === Node.ELEMENT_NODE)) {
                treeRoot.appendChild(treeContent);
                container.appendChild(treeRoot);
            }
        });

        // --- INJECT "SHOW ALL" BUTTON ---
        updateFocusToolbar();
        
        // Update Labels
        const toggleLabel = document.getElementById('toggle-label-text');
        if(toggleLabel) toggleLabel.innerText = isTreeFullyExpanded ? "Collapse All" : "Expand All";
    };

    // 6. Toolbar Helper
    function updateFocusToolbar() {
        const toolbar = document.querySelector('.result-toolbar');
        let focusBtnWrapper = document.getElementById('focus-exit-wrapper');

        if (appState.focusedChapterId) {
            if (!focusBtnWrapper) {
                focusBtnWrapper = document.createElement('div');
                focusBtnWrapper.id = 'focus-exit-wrapper';
                focusBtnWrapper.className = 'btn-wrapper';
                // Button style: Indigo background
                focusBtnWrapper.innerHTML = `
                    <button class="toggle-icon-btn" onclick="exitFocusMode()" style="color: #ffffff; background: #ffffff; border-color: #CBCBCB;">
                        üëÄ
                    </button>
                    <div class="toggle-label">Show All</div>
                `;
                toolbar.insertBefore(focusBtnWrapper, toolbar.firstChild);
            }
        } else {
            if (focusBtnWrapper) {
                focusBtnWrapper.remove();
            }
        }
    }

    // Initialize immediately
    renderChaptersList();

})();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
    function openFileMenu() {
        document.getElementById('file-menu-modal').classList.add('open');
    }

    function closeFileMenu() {
        document.getElementById('file-menu-modal').classList.remove('open');
    }
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<style>
    /* UPDATED: Dynamic width for page numbers */
    .redirect-btn {
        position: absolute;
        top: -18px; /* Pop up slightly higher */
        left: 50%;
        transform: translateX(-50%);
        
        background-color: #fff;
        border: 1px solid #cbd5e1;
        color: #000000;
        
        /* Auto width for numbers like '120' */
        width: auto;
        min-width: 24px; 
        height: 24px;
        padding: 0 6px; /* Space for text */
        border-radius: 12px; /* Pill shape */
        
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 11px; /* Slightly smaller text */
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 50;
        
        opacity: 0;
        pointer-events: none;
        transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* Show on hover */
    .node:hover .redirect-btn {
        opacity: 1;
        pointer-events: auto;
        top: -22px; 
    }

    .redirect-btn:hover {
        background-color: #111184;
        color: white;
        border-color: #4f46e5;
        box-shadow: 0 4px 8px rgba(79, 70, 229, 0.3);
    }
</style>

<script>
    // --- 1. PDF VIEWER WITH INVERT MODE ---
    // --- 1. NUCLEAR RESET PDF LOADER ---
    // --- 1. CSS INJECTION FOR INVERT MODE ---
    // We inject this style once so the .pdf-inverted class actually works
    (function injectPdfStyles() {
        if (document.getElementById('pdf-viewer-styles')) return;
        const style = document.createElement('style');
        style.id = 'pdf-viewer-styles';
        style.innerHTML = `
            /* This is the magic class that inverts colors */
            .pdf-inverted {
                filter: invert(100%) hue-rotate(180deg); 
            }
            /* Optional: transition for smooth toggle */
            #pdf-frame-content {
                transition: filter 0.3s ease;
            }
            /* --- HOVER LOGIC FOR YOUR NEW BUTTON --- */
            #pdf-minimized-btn {
                transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Smooth pop effect */
            }
            #pdf-minimized-btn:hover {
                transform: scale(1.1); /* The 1.1 scale you asked for */
            }
        `;
        document.head.appendChild(style);
    })();

    // --- 2. TOGGLE FUNCTION ---
    window.togglePdfInvert = function() {
        const iframe = document.getElementById('pdf-frame-content');
        if (!iframe) return;
        
        iframe.classList.toggle('pdf-inverted');
        
        // Change the container background to match so we don't see white borders
        const container = iframe.parentElement;
        if (iframe.classList.contains('pdf-inverted')) {
            container.style.background = '#121212'; // Dark background
        } else {
            container.style.background = '#ffffff'; // White background
        }
    };

    // --- 3. WINDOW CONTROLS ---
    window.minimizePdf = function() {
        const modal = document.getElementById('pdf-overlay-modal');
        const btn = document.getElementById('pdf-minimized-btn');
        if (modal) modal.style.display = 'none';
        if (btn) btn.style.display = 'flex';
    };

    window.restorePdf = function() {
        const modal = document.getElementById('pdf-overlay-modal');
        const btn = document.getElementById('pdf-minimized-btn');
        if (modal) modal.style.display = 'flex';
        if (btn) btn.style.display = 'none';
    };

    window.fullyClosePdf = function() {
        const modal = document.getElementById('pdf-overlay-modal');
        const btn = document.getElementById('pdf-minimized-btn');
        const iframe = document.getElementById('pdf-frame-content');
        
        if (modal) modal.style.display = 'none';
        if (btn) btn.style.display = 'none';
        if (iframe) iframe.src = ''; // Stop processing to save memory
    };

    // --- 4. MAIN LOADER FUNCTION ---
    // --- 4. MAIN LOADER FUNCTION (UPDATED FOR FOCUS FIX) ---
    // --- 4. MAIN LOADER FUNCTION (UPDATED FOR ANDROID) ---
    window.openSmartPdf = function(url, isNuclear = false) {
        let modal = document.getElementById('pdf-overlay-modal');

        // A. Create Modal (if it doesn't exist)
        if (!modal) {
            const modalHtml = `
                <div id="pdf-overlay-modal" 
                     tabindex="-1" 
                     onmouseenter="this.focus()"
                     style="position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.9); z-index:2147483647; display:flex; flex-direction:column; outline:none;">
                    
                    <div tabindex="-1" 
                         onmouseenter="this.focus()" 
                         style="background:#0f172a; padding:8px 15px; display:flex; justify-content:space-between; align-items:center; color:white; height:50px; outline:none;">
                        
                        <span style="font-weight:600; font-size: 0.9rem; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; max-width: 120px;">PDF Viewer</span>
                        
                        <div style="display:flex; gap:8px;">
                            <button onclick="const m=document.getElementById('pdf-overlay-modal'); if(m) window.openSmartPdf(m.dataset.currentUrl, true);" 
                                    style="background:#16a34a; color:white; border:none; border-radius:4px; padding:4px 12px; cursor:pointer; font-size: 1.1rem;" 
                                    title="Nuclear [R]eload">‚Üª</button>

                            <button onclick="togglePdfInvert()" style="background:#475569; color:white; border:none; border-radius:4px; padding:4px 12px; cursor:pointer;" title="Dark Mode">üåó</button>
                            <button onclick="minimizePdf()" style="background:#f59e0b; color:white; border:none; border-radius:4px; padding:4px 12px; cursor:pointer;" title="[M]inimize">Min</button>
                            <button onclick="fullyClosePdf()" style="background:#ef4444; color:white; border:none; border-radius:4px; padding:4px 12px; cursor:pointer;" title="[C]lose">√ó</button>
                        </div>
                    </div>
                    
                    <div style="flex:1; background:#fff; position:relative;">
                        <iframe id="pdf-frame-content" style="width:100%; height:100%; border:none;"></iframe>
                    </div>
                </div>

                <div id="pdf-minimized-btn" onclick="restorePdf()" title="[E]xpand" style="display:none; position:fixed; bottom:83px; right:30px; z-index:2147483647; background:#ffffff; color:black; padding:8px 12px; border-radius:50px; cursor:pointer; border:#CBCBCB; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);">‚õ∂</div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            modal = document.getElementById('pdf-overlay-modal');

            // --- KEYBOARD LISTENERS (Keep these for Desktop) ---
            document.addEventListener('keydown', function(e) {
                // 1. SAFETY CHECK: Stop if Notes are Open or user is typing
                const notesModal = document.getElementById('notes-modal');
                const isNotesOpen = notesModal && notesModal.classList.contains('open');
                const isTyping = (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable);
                
                // If notes are open or typing, do NOT trigger PDF shortcuts
                if (isNotesOpen || isTyping) return;

                const minimizedBtn = document.getElementById('pdf-minimized-btn');
                
                // Re-fetch modal here to ensure we have the live reference
                const liveModal = document.getElementById('pdf-overlay-modal');
                
                const isModalOpen = liveModal && liveModal.style.display !== 'none';
                const isMinimized = minimizedBtn && minimizedBtn.style.display !== 'none';

                if (!isModalOpen && !isMinimized) return;
                
                const key = e.key.toLowerCase();

                if (key === 'r' && isModalOpen) {
                    const currentUrl = liveModal.dataset.currentUrl;
                    if (currentUrl) { e.preventDefault(); window.openSmartPdf(currentUrl, true); }
                }
                else if (key === 'e' && isMinimized) { 
                    e.preventDefault(); 
                    restorePdf(); 
                }
                else if (key === 'm' && isModalOpen) { e.preventDefault(); minimizePdf(); }
                else if (key === 'escape' && isModalOpen) { e.preventDefault(); fullyClosePdf(); }
            });
        }

        // B. SAVE URL
        modal.dataset.currentUrl = url;

        const iframe = document.getElementById('pdf-frame-content');
        modal.style.display = 'flex';
        document.getElementById('pdf-minimized-btn').style.display = 'none';
        modal.focus(); 

        // C. PREPARE URL
        const parts = url.split('#');
        const filePath = parts[0];
        const existingHash = parts[1] || '';
        const fullPdfUrl = new URL(filePath, document.baseURI).href;
        
        const uniqueId = Date.now() + '_' + Math.floor(Math.random() * 1000000);
        let finalHash = existingHash ? existingHash : 'page=1';
        if (!finalHash.includes('view=')) finalHash += '&view=FitH'; 
        finalHash += `&uid=${uniqueId}`;
        
        const viewerUrl = `https://mozilla.github.io/pdf.js/web/viewer.html?file=${encodeURIComponent(fullPdfUrl)}#${finalHash}`;

        // D. EXECUTE LOAD STRATEGY
        if (isNuclear) {
            iframe.src = 'about:blank';
            setTimeout(() => {
                iframe.src = viewerUrl;
                // updateDebugBox removed as it might cause errors if element is missing
            }, 50);
        } else {
            iframe.src = viewerUrl;
        }
    };

    // Helper for debug box
    function updateDebugBox(msg, bg, border) {
        let debugBox = document.getElementById('url-debug-display');
        if (debugBox) {
            debugBox.innerHTML = `<strong>${msg}</strong>`;
            debugBox.style.background = bg;
            debugBox.style.borderColor = border;
        }
    }

    // --- 2. NEW INVERT FUNCTION ---
    window.togglePdfInvert = function() {
        const iframe = document.getElementById('pdf-frame-content');
        iframe.classList.toggle('pdf-inverted');
        // If inverted, change background to dark to avoid white flashes
        if (iframe.classList.contains('pdf-inverted')) {
            iframe.parentElement.style.background = '#1a1a1a';
        } else {
            iframe.parentElement.style.background = '#fff';
        }
    };

    // --- 3. WINDOW CONTROLS ---
    window.minimizePdf = function() {
        document.getElementById('pdf-overlay-modal').style.display = 'none';
        document.getElementById('pdf-minimized-btn').style.display = 'flex';
    };

    window.restorePdf = function() {
        document.getElementById('pdf-minimized-btn').style.display = 'none';
        document.getElementById('pdf-overlay-modal').style.display = 'flex';
    };

    window.fullyClosePdf = function() {
        document.getElementById('pdf-overlay-modal').style.display = 'none';
        document.getElementById('pdf-minimized-btn').style.display = 'none';
        document.getElementById('pdf-frame-content').src = '';
    };

    // --- 4. TREE RENDERER (Standard) ---
    window.buildTreeHTML = function(node, level, inheritedLink = '') {
        
        let masterLink = inheritedLink;
        if (level === 0 && node.link) {
            masterLink = node.link;
        }

        if (appState.isolationMode && !appState.validIsolatedIds.has(node.id)) return document.createDocumentFragment(); 
        if (window.isSearchActive) {
            const isMatch = window.searchMatches.has(node.id);
            const isPath = window.searchPathNodes.has(node.id);
            if (!isMatch && !isPath) return document.createDocumentFragment();
        }

        const li = document.createElement('li');
        const card = document.createElement('div');
        const hasChild = node.children && node.children.length > 0;
        const isCollapsed = appState.expandedNodes.has(node.id);
        const hasNotes = node.notes && node.notes.trim().length > 0;
        const isSelected = selectedNodeIds.has(node.id);
        
        const nodePage = node.pdfPage; 
        // FIX: Check if this node is the source of a move (Green Highlight)
        const isMoveSource = (window.mobileState && window.mobileState.srcId === node.id && window.mobileState.tool === 'move');
        let redirectBtn = '';

        if (masterLink && masterLink.trim() !== '') {
            const baseUrl = masterLink.split('#')[0];
            
            if (nodePage && nodePage.trim() !== '') {
                const finalUrl = `${baseUrl}#page=${nodePage}`;
                redirectBtn = `
                    <button class="redirect-btn" 
                       title="Page ${nodePage}" 
                       onmousedown="event.stopPropagation()" 
                       onclick="event.stopPropagation(); openSmartPdf('${finalUrl}')">
                       ${nodePage}
                    </button>
                `;
            }  
            //     else {
            //     redirectBtn = `
            //         <button class="redirect-btn" 
            //            title="Open PDF" 
            //            onmousedown="event.stopPropagation()" 
            //            onclick="event.stopPropagation(); openSmartPdf('${baseUrl}')">
            //            üåê
            //         </button>
            //     `;
            // }
        }

        card.id = 'node-' + node.id;
        
        // FIX: Added ${isMoveSource ? 'move-active' : ''} to the class list
        let cssClasses = `node level-${Math.min(level,3)} ${isCollapsed?'collapsed':''} ${isSelected?'node-selected':''} ${isMoveSource ? 'move-active' : ''}`;
        
        if (window.searchMatches && window.searchMatches.has(node.id)) cssClasses += ' search-match';
        else if (window.searchPathNodes && window.searchPathNodes.has(node.id)) cssClasses += ' search-path';
        card.className = cssClasses;

        if(typeof handleHover === 'function') {
            card.onmouseenter = (e) => handleHover(e, card);
            card.onmouseleave = (e) => handleHover(e, card);
        }
        if(typeof trackMouse === 'function') card.onmousemove = (e) => trackMouse(e);

        const expander = hasChild ? `<span class="expander">${isCollapsed?'+':'-'}</span>` : '';
        const bulb = `<button class="bulb-btn ${hasNotes?'has-notes':''}" onclick="openNotesModal(event,'${node.id}')">‚ú¶</button>`;
        const desc = node.desc ? `<p>${node.desc}</p>` : '';
        
        card.innerHTML = `<h4>${node.title}</h4>${desc}${expander}${bulb}${redirectBtn}`;
        
        card.draggable = true;
        card.ondragstart = (e) => handleVisDragStart(e, node.id);
        card.ondragover = (e) => handleVisDragOver(e, node.id);
        card.ondragleave = (e) => handleVisDragLeave(e);
        card.ondrop = (e) => handleVisDrop(e, node.id);
        card.onclick = (e) => handleNodeClick(e, node);
        
        li.appendChild(card);
        
        if(hasChild && !isCollapsed) {
            const ul = document.createElement('ul');
            node.children.forEach(child => {
                const childNode = buildTreeHTML(child, level+1, masterLink);
                if(childNode && (childNode.childNodes.length > 0 || childNode.nodeType === Node.ELEMENT_NODE)) {
                    ul.appendChild(childNode);
                }
            });
            if(ul.children.length > 0) li.appendChild(ul);
        }
        
        if(level === 0) {
            const ul = document.createElement('ul');
            ul.style.paddingLeft = '0';
            ul.appendChild(li);
            return ul;
        }
        return li;
    };

    if(typeof renderVisualizer === 'function') renderVisualizer();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
    // --- KEYBOARD SHORTCUTS ---
    document.addEventListener('keydown', function(e) {
        // 1. SAFETY CHECK:
        // Do not trigger shortcuts if the user is currently typing in an input, textarea, or content editable area.
        const tag = e.target.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) {
            return; 
        }

        // 2. Ignore if holding Ctrl/Alt/Meta (to allow browser shortcuts)
        if (e.ctrlKey || e.altKey || e.metaKey) return;

        // --- NEW: FILE MENU SHORTCUTS ---
        // These only activate when the File Menu is visible on screen
        const fileMenu = document.getElementById('file-menu-modal');
        const isFileMenuOpen = fileMenu && fileMenu.classList.contains('open');

        if (isFileMenuOpen) {
            switch(e.key.toLowerCase()) {
                case 't': 
                    e.preventDefault(); 
                    closeFileMenu(); 
                    chooseImport('bulk'); 
                    break; // Text/Bulk
                case 'j': 
                    e.preventDefault(); 
                    closeFileMenu(); 
                    chooseImport('json'); 
                    break; // JSON Import
                case 'd': 
                    e.preventDefault(); 
                    closeFileMenu(); 
                    chooseExport('json'); 
                    break; // JSON Data Export
                case 'c': 
                    e.preventDefault(); 
                    closeFileMenu(); 
                    saveToCloud(); 
                    break;        // Cloud Save
                case 'h': 
                    e.preventDefault(); 
                    closeFileMenu(); 
                    chooseExport('html'); 
                    break; // HTML Export
                case 'escape':
                    e.preventDefault();
                    closeFileMenu();
                    break; // Close Menu
            }
            // If the menu is open, we don't want to trigger the global shortcuts below
            return; 
        }

        // --- NEW: TRACE MODE SHORTCUTS (t, h, a, f) ---
        // Only active if Master Trace is turned ON
        if (typeof traceState !== 'undefined' && traceState.master) {
            const k = e.key.toLowerCase();
            let btnClass = null;
            let modeName = null;

            if (k === 't') { modeName = 'text'; btnClass = '.icon-text'; }
            else if (k === 'h') { modeName = 'highlight'; btnClass = '.icon-glow'; }
            else if (k === 'a') { modeName = 'align'; btnClass = '.icon-align'; }
            else if (k === 'f') { modeName = 'focus'; btnClass = '.icon-focus'; }

            if (modeName && btnClass) {
                const targetBtn = document.querySelector(`.btn-sub-opt${btnClass}`);
                if (targetBtn) {
                    e.preventDefault();
                    toggleSubState(modeName, targetBtn);
                    return; // Stop other global shortcuts
                }
            }
        }

        // 3. GLOBAL SHORTCUT LOGIC (When menu is NOT open)
        switch(e.key) {

            // 's' or 'S': Open Subject Modal
            case 's':
            case 'S':
                e.preventDefault();
                openSubjectModal();
                // Auto-focus the input inside the modal for speed
                setTimeout(() => {
                    const input = document.getElementById('new-subject-input');
                    if(input) input.focus();
                }, 100);
                break;

            // 'i' or 'I': Open File Menu (Import/Export üìÅ)
            case 'i':
            case 'I':
                e.preventDefault();
                openFileMenu();
                break;
        }
    });
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<style>
    /* Base style for Page Inputs */
    .page-input {
        width: 60px !important; 
        text-align: center;
        padding: 0.4rem !important;
        font-size: 0.9rem;
        font-weight: bold;
        border-width: 1px;
        border-style: solid;
    }

    /* Chapter Level (Blue) */
    .page-chap {
        background-color: #eff6ff;
        border-color: #bfdbfe;
        color: #1d4ed8;
    }
    .page-chap:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    .page-chap::placeholder { color: #bfdbfe; font-weight: normal; }

    /* Level 1 (Pink) */
    .page-l1 {
        background-color: #fff0f7;
        border-color: #fbcfe8;
        color: #be185d;
    }
    .page-l1:focus {
        border-color: #d63384;
        box-shadow: 0 0 0 3px rgba(214, 51, 132, 0.1);
    }
    .page-l1::placeholder { color: #fbcfe8; font-weight: normal; }

    /* Level 2 (Orange) */
    .page-l2 {
        background-color: #fff7ed;
        border-color: #fed7aa;
        color: #c2410c;
    }
    .page-l2:focus {
        border-color: #e67e22;
        box-shadow: 0 0 0 3px rgba(230, 126, 34, 0.1);
    }
    .page-l2::placeholder { color: #fed7aa; font-weight: normal; }

    /* Level 3 (Green) */
    .page-l3 {
        background-color: #f0fdf4;
        border-color: #86efac;
        color: #059669;
    }
    .page-l3:focus {
        border-color: #059669;
        box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
    }
    .page-l3::placeholder { color: #86efac; font-weight: normal; }
</style>

<script>
(function() {
    // --- NEW HELPER: Copy Link from Previous Chapter ---
    window.copyLinkFromPrevious = function() {
        const sub = getActiveSubject();
        const currentId = appState.activeChapterId;
        const currentIndex = sub.chapters.findIndex(c => c.id === currentId);

        if (currentIndex > 0) {
            const prevChap = sub.chapters[currentIndex - 1];
            if (prevChap.link && prevChap.link.trim() !== '') {
                const currentChap = sub.chapters[currentIndex];
                
                // Update the link
                currentChap.link = prevChap.link;
                saveData();
                
                // Refresh the specific input to show the new value immediately
                const input = document.querySelector('.link-input');
                if (input) {
                    input.value = currentChap.link;
                    // Visual feedback (flash green)
                    input.style.backgroundColor = '#dcfce7';
                    setTimeout(() => input.style.backgroundColor = '', 500);
                }
            } else {
                alert("The previous chapter does not have a link.");
            }
        } else {
            alert("This is the first chapter; there is no previous tab to copy from.");
        }
    };
    // 1. NEW FUNCTION: Update Chapter Page
    window.updateChapterPage = function(val) {
        const chap = getActiveChapter();
        if(chap) {
            chap.pdfPage = val;
            saveData();
            renderVisualizer(); // Optional: if visualizer displays chapter page
        }
    };

    // 2. NEW FUNCTION: Update Level 1 Page
    window.updateLevel1Page = function(val) {
        const l1 = getActiveLevel1();
        if(l1) { 
            l1.pdfPage = val; 
            saveData(); 
            renderVisualizer(); 
        }
    };

    // 3. NEW FUNCTION: Update Node (L2/L3) Page
    window.updateNodePage = function(id, val) {
        const l1 = getActiveLevel1();
        
        // Check Level 2
        let n = l1.children.find(x => x.id === id);
        if(n) { 
            n.pdfPage = val; 
            saveData(); 
            renderVisualizer(); 
            return; 
        }

        // Check Level 3
        l1.children.forEach(l2 => {
            let l3 = l2.children.find(x => x.id === id);
            if(l3) { 
                l3.pdfPage = val; 
                saveData(); 
                renderVisualizer(); 
            }
        });
    };

    // 4. OVERRIDE: Render Editor
    window.renderEditor = function() {
        const container = document.getElementById('editor-area');
        const status = document.getElementById('editor-status');
        const chap = getActiveChapter();
        
        if(!chap) { container.innerHTML = ''; status.innerText = ''; return; }
        const l1 = getActiveLevel1();
        
        // --- CHAPTER CARD ---
        let html = `
            <div class="section-card" style="background:#f8fafc; border-color:#e2e8f0;">
                <div class="input-group">
                    <label class="input-label">Chapter Title</label>
                    <div style="display: flex; gap: 10px;">
                        <input class="text-input chapter-input" style="flex:1;" data-node-id="${chap.id}" autocomplete="off" type="text" value="${chap.title}" onchange="updateChapterTitle(this.value)" placeholder="Chapter Name">
                        <input class="text-input page-input page-chap" autocomplete="off" type="text" value="${chap.pdfPage || ''}" onchange="updateChapterPage(this.value)" placeholder="Pg No">
                    </div>
                </div>
                
                <div class="input-group" style="margin-top: 0.8rem; margin-bottom:0;">
                    <label class="input-label">Link Address (Applies to all nodes)</label>
                    <div style="display: flex; gap: 8px;">
                        <input class="text-input link-input" style="flex:1;" autocomplete="off" type="text" value="${chap.link || ''}" onchange="updateChapterLink(this.value)" placeholder="https://...">
                        
                        <button class="btn-action" onclick="copyLinkFromPrevious()" title="Copy Link from Previous Chapter" style="background:white; border:1px solid #cbd5e1; padding: 0 12px;">
                            üìã 
                        </button>
                    </div>
                </div>
            </div>
        `;

        if (!l1) { html += '<div class="empty-msg">Select or create a Level 1 tab to edit its content.</div>'; container.innerHTML = html; status.innerText = 'Editing Chapter Settings'; return; }
        status.innerText = `Editing: ${l1.title}`;

        // --- LEVEL 1 CARD ---
        html += `
            <div class="section-card">
                <div class="input-group">
                    <label class="input-label">Level 1 Title</label>
                    <div style="display: flex; gap: 10px;">
                        <input class="text-input level-1-input" style="flex:1;" data-node-id="${l1.id}" autocomplete="off" type="text" value="${l1.title}" onchange="updateLevel1Title(this.value)">
                        <input class="text-input page-input page-l1" autocomplete="off" type="text" value="${l1.pdfPage || ''}" onchange="updateLevel1Page(this.value)" placeholder="Pg No">
                    </div>
                </div>
                <div class="input-group">
                    <label class="input-label">Description</label>
                    <input class="text-input desc-input" autocomplete="off" type="text" value="${l1.desc || ''}" onchange="updateLevel1Desc(this.value)">
                </div>
                <div style="margin-top:2rem; padding-top:1rem; border-top:1px solid #eee;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:1rem;">
                        <span class="input-label" style="margin:0;">Level 2 Items</span>
                        <button class="btn-add orange" onclick="addLevel2()">+ Add Level 2</button>
                    </div>
                    <div id="l2-container"></div>
                </div>
            </div>
        `;
        container.innerHTML = html;
        
        // --- CHILDREN RENDER LOOP ---
        const l2Container = document.getElementById('l2-container');
        l1.children.forEach(l2 => {
            const blk = document.createElement('div');
            blk.className = 'level2-block';
            let l3Html = '';
            l2.children.forEach(l3 => {
                // Level 3 Row
                l3Html += `
                    <div class="level3-row">
                        <div style="flex:1; display:flex; flex-direction:column; gap:4px;">
                            <div style="display:flex; gap: 5px;">
                                <input class="text-input level-3-input" style="flex:1; padding:0.4rem; font-size:0.9rem;" data-node-id="${l3.id}" autocomplete="off" value="${l3.title}" onchange="updateNodeTitle('${l3.id}', this.value)" placeholder="Level 3 Title">
                                <input class="text-input page-input page-l3" style="height: auto;" autocomplete="off" type="text" value="${l3.pdfPage || ''}" onchange="updateNodePage('${l3.id}', this.value)" placeholder="Pg">
                            </div>
                            <input class="text-input desc-input" autocomplete="off" style="padding:0.3rem; font-size:0.8rem;" value="${l3.desc || ''}" onchange="updateNodeDesc('${l3.id}', this.value)" placeholder="Description (Optional)">
                        </div>
                        <button class="btn-icon" onclick="deleteNode('${l3.id}', '${l2.id}')">√ó</button>
                    </div>
                `;
            });
            // Level 2 Block
            blk.innerHTML = `
                <div class="level2-header">
                    <div class="level2-title-row">
                        <input class="text-input level-2-input" style="flex:1;" data-node-id="${l2.id}" autocomplete="off" value="${l2.title}" onchange="updateNodeTitle('${l2.id}', this.value)" placeholder="Level 2 Title">
                        <input class="text-input page-input page-l2" autocomplete="off" type="text" value="${l2.pdfPage || ''}" onchange="updateNodePage('${l2.id}', this.value)" placeholder="Pg">
                        <button class="btn-icon" onclick="deleteNode('${l2.id}', '${l1.id}')">√ó</button>
                    </div>
                    <input class="text-input desc-input" autocomplete="off" value="${l2.desc || ''}" onchange="updateNodeDesc('${l2.id}', this.value)" placeholder="Level 2 Description (Optional)">
                </div>
                <div class="level3-list">
                    ${l3Html}
                    <button class="btn-add orange" style="background:#e0f2f1; color:#059669; margin-top:0.5rem;" onclick="addLevel3('${l2.id}')">+ L3</button>
                </div>
            `;
            l2Container.appendChild(blk);
        });
    };
    
    // Refresh the view immediately
    if(typeof renderEditor === 'function') renderEditor();
})();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
    /**
     * HOVER INTERACTION UPDATE
     * 1. Opens Notes on Bulb Hover.
     * 2. Closes Notes when mouse leaves the Modal Box (Only in View Mode).
     */

    (function setupHoverInteractions() {
        
        // 1. Attach Mouse Leave Event to the Note Modal
        const noteModal = document.querySelector('#notes-modal .modal.large-modal');
        if (noteModal) {
            noteModal.onmouseleave = function() {
                // SAFETY: Do not auto-close if user is typing (Edit Mode)
                if (typeof isNoteEditMode !== 'undefined' && isNoteEditMode) {
                    return; 
                }
                closeNotesModal();
            };
        }

        // 2. OVERRIDE: buildTreeHTML
        // We update the specific line for the bulb button to include 'onmouseenter'
        // This includes all previous logic (Isolation, Search, PDF Links, Moving)
        window.buildTreeHTML = function(node, level, inheritedLink = '') {
            
            // --- INHERITANCE LOGIC ---
            let masterLink = inheritedLink;
            if (level === 0 && node.link) {
                masterLink = node.link;
            }

            // --- FILTER LOGIC ---
            if (appState.isolationMode && !appState.validIsolatedIds.has(node.id)) return document.createDocumentFragment(); 
            if (window.isSearchActive) {
                const isMatch = window.searchMatches.has(node.id);
                const isPath = window.searchPathNodes.has(node.id);
                if (!isMatch && !isPath) return document.createDocumentFragment();
            }

            const li = document.createElement('li');
            const card = document.createElement('div');
            const hasChild = node.children && node.children.length > 0;
            const isCollapsed = appState.expandedNodes.has(node.id);
            const hasNotes = node.notes && node.notes.trim().length > 0;
            const isSelected = selectedNodeIds.has(node.id);
            const nodePage = node.pdfPage; 
            const isMoveSource = (window.mobileState && window.mobileState.srcId === node.id && window.mobileState.tool === 'move');
            
            // --- PDF BUTTON GENERATION ---
            let redirectBtn = '';
            if (masterLink && masterLink.trim() !== '') {
                const baseUrl = masterLink.split('#')[0];
                if (nodePage && nodePage.trim() !== '') {
                    const finalUrl = `${baseUrl}#page=${nodePage}`;
                    redirectBtn = `
                        <button class="redirect-btn" 
                           title="Page ${nodePage}" 
                           onmousedown="event.stopPropagation()" 
                           onclick="event.stopPropagation(); openSmartPdf('${finalUrl}')">
                           ${nodePage}
                        </button>
                    `;
                }  
            }

            // --- CARD SETUP ---
            card.id = 'node-' + node.id;
            let cssClasses = `node level-${Math.min(level,3)} ${isCollapsed?'collapsed':''} ${isSelected?'node-selected':''} ${isMoveSource ? 'move-active' : ''}`;
            
            if (window.searchMatches && window.searchMatches.has(node.id)) cssClasses += ' search-match';
            else if (window.searchPathNodes && window.searchPathNodes.has(node.id)) cssClasses += ' search-path';
            card.className = cssClasses;

            // --- EVENTS ---
            if(typeof handleHover === 'function') {
                card.onmouseenter = (e) => handleHover(e, card);
                card.onmouseleave = (e) => handleHover(e, card);
            }
            if(typeof trackMouse === 'function') card.onmousemove = (e) => trackMouse(e);

            // --- CONTENT GENERATION ---
            const expander = hasChild ? `<span class="expander">${isCollapsed?'+':'-'}</span>` : '';
            const desc = node.desc ? `<p>${node.desc}</p>` : '';
            
            // *** UPDATED BULB BUTTON: Added onmouseenter event ***
            const bulb = `<button class="bulb-btn ${hasNotes?'has-notes':''}" 
                            onclick="openNotesModal(event,'${node.id}')" 
                            onmouseenter="openNotesModal(event,'${node.id}')">‚ú¶</button>`;
            
            card.innerHTML = `<h4>${node.title}</h4>${desc}${expander}${bulb}${redirectBtn}`;
            
            card.draggable = true;
            card.ondragstart = (e) => handleVisDragStart(e, node.id);
            card.ondragover = (e) => handleVisDragOver(e, node.id);
            card.ondragleave = (e) => handleVisDragLeave(e);
            card.ondrop = (e) => handleVisDrop(e, node.id);
            card.onclick = (e) => handleNodeClick(e, node);
            
            li.appendChild(card);
            
            if(hasChild && !isCollapsed) {
                const ul = document.createElement('ul');
                node.children.forEach(child => {
                    const childNode = buildTreeHTML(child, level+1, masterLink);
                    if(childNode && (childNode.childNodes.length > 0 || childNode.nodeType === Node.ELEMENT_NODE)) {
                        ul.appendChild(childNode);
                    }
                });
                if(ul.children.length > 0) li.appendChild(ul);
            }
            
            if(level === 0) {
                const ul = document.createElement('ul');
                ul.style.paddingLeft = '0';
                ul.appendChild(li);
                return ul;
            }
            return li;
        };

        // Re-render to apply the new button logic immediately
        if(typeof renderVisualizer === 'function') renderVisualizer();

    })();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
    /**
     * COPY ON MULTI-SELECT UPDATE (Trace Path Version)
     * Copies the full ancestor path (e.g., "Chapter > Level 1 > Node") when selected.
     */
    (function enableAutoCopy() {
        const previousHandler = window.handleNodeClick;

        // Helper: Find the path of TITLES from root to target
        function getPathTitles(chapters, targetId) {
            for (let chap of chapters) {
                const path = findPathRecursive(chap, targetId);
                if (path) return path;
            }
            return null;
        }

        // Recursive search to build the title array
        function findPathRecursive(node, targetId) {
            if (node.id === targetId) {
                return [node.title];
            }
            if (node.children) {
                for (let child of node.children) {
                    const path = findPathRecursive(child, targetId);
                    if (path) {
                        // Prepend current node title to the result from child
                        return [node.title, ...path];
                    }
                }
            }
            return null;
        }

        window.handleNodeClick = function(e, node) {
            // Check state BEFORE click
            const wasSelected = (typeof isSelectionMode !== 'undefined' && isSelectionMode) 
                                ? selectedNodeIds.has(node.id) 
                                : false;

            // Execute original logic
            if (previousHandler) previousHandler(e, node);

            // Check state AFTER click
            if (typeof isSelectionMode !== 'undefined' && isSelectionMode) {
                const isSelected = selectedNodeIds.has(node.id);
                
                // If newly selected
                if (!wasSelected && isSelected) {
                    const sub = getActiveSubject();
                    const titles = getPathTitles(sub.chapters, node.id);
                    
                    if (titles) {
                        // Join with " > " to create the trace path string
                        // You can change ' > ' to ' _ ' or '\n' if preferred
                        const textToCopy = titles.join(' > ');
                        
                        navigator.clipboard.writeText(textToCopy).catch(err => {
                            console.warn("Clipboard write failed:", err);
                        });
                    }
                }
            }
        };
    })();
</script>


<!----------------------------------------------------------------------------------------------------------------------------->

<script>
/**
 * FEATURE UPDATE: Freeze Alignment (Ctrl) & Click-to-Exit
 * -------------------------------------------------------
 * 1. Freeze: Hold CTRL while hovering to lock alignment.
 * 2. Exit + Action: Click any node while holding CTRL to turn Align Mode OFF,
 * BUT still perform the standard click action (expand/collapse).
 */
(function() {
    // 1. Global Freeze State
    window.isAlignFrozen = false;

    // 2. Override resetView: Prevent resetting if Frozen
    const originalResetView = window.resetView;
    window.resetView = function() {
        if (window.isAlignFrozen && typeof traceState !== 'undefined' && traceState.align) return;
        if (originalResetView) originalResetView();
    };

    // 3. Override handleHover: Prevent calculating new paths if Frozen
    const originalHandleHover = window.handleHover;
    window.handleHover = function(e, card) {
        if (window.isAlignFrozen && typeof traceState !== 'undefined' && traceState.align) return;
        if (originalHandleHover) originalHandleHover(e, card);
    };

    // 4. Keyboard Listeners
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Control' && typeof traceState !== 'undefined' && traceState.align) {
            window.isAlignFrozen = true;
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'Control') {
            window.isAlignFrozen = false;
            if (typeof traceState !== 'undefined' && traceState.align) {
                resetView();
            }
        }
    });

    // 5. Override Node Click
    const originalHandleClick = window.handleNodeClick;
    window.handleNodeClick = function(e, node) {
        
        // CHECK: Is Ctrl Held AND Align Mode Active?
        if (e.ctrlKey && typeof traceState !== 'undefined' && traceState.align) {
            
            // A. Force Unfreeze
            window.isAlignFrozen = false;

            // B. Turn off Align Mode
            const alignBtn = document.querySelector('.btn-sub-opt.icon-align');
            if (typeof toggleSubState === 'function' && alignBtn) {
                toggleSubState('align', alignBtn); 
            } else {
                traceState.align = false;
                if(alignBtn) alignBtn.classList.remove('btn-on');
            }

            // C. Reset visual transforms immediately
            if (typeof resetView === 'function') {
                // We must bypass our own override to ensure it clears NOW
                // Since isAlignFrozen is false, calling resetView() works.
                resetView(); 
            }
            
            // D. IMPORTANT: Do NOT return or stop propagation.
            // Let the code continue to run the standard click handler below.
        }

        // Run the standard "Click Effect" (Expand/Collapse/Select)
        if (originalHandleClick) originalHandleClick(e, node);
    };

})();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
(function enableTreeNavigation() {
    // 1. State for Keyboard Focus
    window.navFocusId = null;

    // 2. Helper: Apply Visual Focus
    function applyNavFocus(id) {
        document.querySelectorAll('.node.key-focused').forEach(el => el.classList.remove('key-focused'));
        if (!id) return;

        const el = document.getElementById('node-' + id);
        if (el) {
            window.navFocusId = id;
            el.classList.add('key-focused');
            el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
        }
    }

    // 3. Helper: Get Visible Nodes
    function getVisibleNodes() {
        return Array.from(document.querySelectorAll('#result-container .node'));
    }

    // 4. Helper: Visual Flash for Copy
    function flashCopySuccess(id) {
        const el = document.getElementById('node-' + id);
        if(!el) return;
        
        const oldBorder = el.style.borderColor;
        const oldBg = el.style.backgroundColor;
        
        el.style.transition = 'none';
        el.style.borderColor = '#22c55e'; 
        el.style.backgroundColor = '#dcfce7'; 
        
        setTimeout(() => {
            el.style.transition = 'all 0.5s ease';
            el.style.borderColor = oldBorder;
            el.style.backgroundColor = oldBg;
        }, 200);
    }

    // 5. Override renderVisualizer
    const originalRender = window.renderVisualizer;
    window.renderVisualizer = function() {
        if (originalRender) originalRender();
        if (window.navFocusId) applyNavFocus(window.navFocusId);
    };

    // 6. Sync Click
    const originalHandleClick = window.handleNodeClick;
    window.handleNodeClick = function(e, node) {
        if (originalHandleClick) originalHandleClick(e, node);
        applyNavFocus(node.id);
    };

    // 7. MAIN KEYBOARD LISTENER (Capture Phase)
    window.addEventListener('keydown', function(e) {
        
        // --- 0. MODAL GUARD (Notes & PDF) ---
        // If either overlay is open, STOP here. 
        // This prevents view switching but allows typing/shortcuts inside the modal.
        const notesModal = document.getElementById('notes-modal');
        const isNotesOpen = notesModal && notesModal.classList.contains('open');
        
        const pdfModal = document.getElementById('pdf-overlay-modal');
        const isPdfOpen = pdfModal && pdfModal.style.display !== 'none';

        if (isNotesOpen || isPdfOpen) {
            return; 
        }

        // --- A. TEXT SELECTION GUARD (Ctrl + Shift + Arrow) ---
        if (e.ctrlKey && e.shiftKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
            e.stopPropagation(); 
            return; 
        }

        // --- B. VIEW SWITCHING (Ctrl + Arrow ONLY) ---
        if (e.ctrlKey && !e.shiftKey) {
            if (e.key === 'ArrowLeft') { 
                e.preventDefault(); e.stopPropagation(); 
                document.activeElement.blur(); 
                switchView('input'); 
                return; 
            }
            if (e.key === 'ArrowRight') { 
                e.preventDefault(); e.stopPropagation(); 
                document.activeElement.blur(); 
                switchView('result'); 
                return; 
            }
        }

        // --- SAFETY CHECK (Typing in Main View) ---
        const tag = e.target.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
        
        // --- C. TREE NAVIGATION (Result View Only) ---
        const isResultView = document.getElementById('result-view').classList.contains('active-view');
        
        if (isResultView) {
            
            // COPY LOGIC
            if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C')) {
                if (window.navFocusId) {
                    const el = document.getElementById('node-' + window.navFocusId);
                    if (el) {
                        e.preventDefault(); 
                        const title = el.querySelector('h4').innerText;
                        navigator.clipboard.writeText(title).then(() => {
                            flashCopySuccess(window.navFocusId);
                        });
                    }
                }
                return; 
            }

            const visibleNodes = getVisibleNodes();
            if (visibleNodes.length === 0) return;

            let currentIndex = -1;
            if (window.navFocusId) currentIndex = visibleNodes.findIndex(el => el.id === `node-${window.navFocusId}`);

            if (currentIndex === -1 && e.key.startsWith('Arrow')) {
                applyNavFocus(visibleNodes[0].id.replace('node-', ''));
                return;
            }

            const currentNode = visibleNodes[currentIndex];
            
            if (e.key === 'ArrowDown') {
                e.preventDefault(); e.stopPropagation();
                const nextIndex = Math.min(currentIndex + 1, visibleNodes.length - 1);
                applyNavFocus(visibleNodes[nextIndex].id.replace('node-', ''));
            }
            else if (e.key === 'ArrowUp') {
                e.preventDefault(); e.stopPropagation();
                const prevIndex = Math.max(currentIndex - 1, 0);
                applyNavFocus(visibleNodes[prevIndex].id.replace('node-', ''));
            }
            else if (e.key === 'ArrowRight') {
                e.preventDefault(); e.stopPropagation();
                if (currentNode.classList.contains('collapsed')) {
                    currentNode.click(); 
                } else {
                    const nextIndex = Math.min(currentIndex + 1, visibleNodes.length - 1);
                    applyNavFocus(visibleNodes[nextIndex].id.replace('node-', ''));
                }
            }
            else if (e.key === 'ArrowLeft') {
                e.preventDefault(); e.stopPropagation();
                const hasExpander = currentNode.querySelector('.expander');
                const isCollapsed = currentNode.classList.contains('collapsed');

                if (hasExpander && !isCollapsed) {
                    currentNode.click(); 
                } else {
                    const parentLi = currentNode.closest('li').parentElement.closest('li');
                    if (parentLi) {
                        const parentNode = parentLi.querySelector('.node');
                        if (parentNode) applyNavFocus(parentNode.id.replace('node-', ''));
                    }
                }
            }
            else if (e.key === 'Enter' && !e.ctrlKey) {
                e.preventDefault();
                currentNode.click();
            }
        }
    }, true); 
})();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

<script>
(function enableEditorDragging() {

    // 1. GLOBAL STATE FOR EDITOR DRAG
    // We need to track the 'parent ID' for Level 3 items so we don't drag them into the wrong list.
    window.dragParentId = null;

    // 2. OVERRIDE: HANDLE DRAG START
    // Updated to accept a 'parentId' (essential for Level 3 items)
    window.handleDragStart = function(e, index, type, parentId = null) {
        // Prevent conflict with text selection
        if (e.target.tagName === 'INPUT') return e.preventDefault();
        
        dragSrcIndex = index;
        dragType = type;
        window.dragParentId = parentId; // Save the parent ID (e.g., the Level 2 ID)
        
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', type); // For compatibility
        
        // Visual feedback
        setTimeout(() => e.target.classList.add('dragging'), 0);
    };

    // 3. OVERRIDE: HANDLE DROP
    // --- HELPER: Remove existing Number or Letter prefixes ---
    function cleanTitle(title) {
        // Regex removes "1. ", "12. ", "A. ", "Z. " from start of string
        return title.replace(/^([0-9]+|[A-Z]+)\.\s*/, '');
    }

    // --- UPDATED: HANDLE DROP WITH SPECIFIC FORMATTING ---
    window.handleDrop = function(e, index, type, targetParentId = null) {
        e.stopPropagation();
        e.preventDefault();
        
        // Cleanup visual styles
        const item = e.target.closest('.draggable-item') || e.target.closest('.level2-block') || e.target.closest('.level3-row');
        if (item) item.classList.remove('drag-over', 'dragging');
        document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));

        // Validation
        if (dragSrcIndex === null || dragType !== type || dragSrcIndex === index) return false;
        
        // Strict Check: Level 3 items can currently only be reordered within the SAME Level 2 parent
        if (type === 'level3' && dragParentId !== targetParentId) return false;

        const sub = getActiveSubject();

        // --- RENUMBERING LOGIC ---
        const renumberList = (list, itemType) => {
            list.forEach((node, idx) => {
                const clean = cleanTitle(node.title);
                let prefix = '';

                if (itemType === 'level2') {
                    // Level 2 = Capital Alpha (A., B., C...)
                    // 65 is the ASCII code for 'A'
                    prefix = String.fromCharCode(65 + idx) + '.';
                } else {
                    // Level 1 & Level 3 = Numeric (1., 2., 3...)
                    prefix = (idx + 1) + '.';
                }

                node.title = `${prefix} ${clean}`;
            });
        };

        // 1. Reorder Chapters (No renumbering)
        if (type === 'chapter') {
            const items = [...sub.chapters];
            const [moved] = items.splice(dragSrcIndex, 1);
            items.splice(index, 0, moved);
            sub.chapters = items;
            saveData();
            renderChaptersList();
        } 
        // 2. Reorder Level 1 (Numbers: 1, 2, 3...)
        else if (type === 'level1') {
            const chap = getActiveChapter();
            if (chap) {
                const items = [...chap.children];
                const [moved] = items.splice(dragSrcIndex, 1);
                items.splice(index, 0, moved);
                
                renumberList(items, 'level1'); // Apply Numbers

                chap.children = items;
                saveData();
                renderLevel1List();
            }
        }
        // 3. Reorder Level 2 (Alpha: A, B, C...)
        else if (type === 'level2') {
            const l1 = getActiveLevel1();
            if (l1) {
                const items = [...l1.children];
                const [moved] = items.splice(dragSrcIndex, 1);
                items.splice(index, 0, moved);
                
                renumberList(items, 'level2'); // Apply Letters

                l1.children = items;
                saveData();
                renderEditor(); 
            }
        }
        // 4. Reorder Level 3 (Numbers: 1, 2, 3...)
        else if (type === 'level3') {
            const l1 = getActiveLevel1();
            const l2 = l1.children.find(n => n.id === targetParentId);
            if (l2) {
                const items = [...l2.children];
                const [moved] = items.splice(dragSrcIndex, 1);
                items.splice(index, 0, moved);
                
                renumberList(items, 'level3'); // Apply Numbers

                l2.children = items;
                saveData();
                renderEditor();
            }
        }
        
        // Reset Globals
        dragSrcIndex = null;
        dragType = null;
        dragParentId = null;
        return false;
    };

    // 4. HELPER: GENERIC DRAG OVER
    window.handleEditorDragOver = function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const el = e.target.closest('.draggable-item') || e.target.closest('.level2-block') || e.target.closest('.level3-row');
        if (el) el.classList.add('drag-over');
    };

    window.handleEditorDragLeave = function(e) {
        const el = e.target.closest('.draggable-item') || e.target.closest('.level2-block') || e.target.closest('.level3-row');
        if (el) el.classList.remove('drag-over');
    };

    // 5. OVERRIDE: RENDER EDITOR
    // Updated to include draggable attributes and handles (‚ãÆ‚ãÆ)
    window.renderEditor = function() {
        const container = document.getElementById('editor-area');
        const status = document.getElementById('editor-status');
        const chap = getActiveChapter();
        
        if(!chap) { container.innerHTML = ''; status.innerText = ''; return; }
        const l1 = getActiveLevel1();
        
        // --- CHAPTER CARD ---
        let html = `
            <div class="section-card" style="background:#f8fafc; border-color:#e2e8f0;">
                <div class="input-group">
                    <label class="input-label">Chapter Title</label>
                    <div style="display: flex; gap: 10px;">
                        <input class="text-input chapter-input" style="flex:1;" data-node-id="${chap.id}" autocomplete="off" type="text" value="${chap.title}" onchange="updateChapterTitle(this.value)" placeholder="Chapter Name">
                        <input class="text-input page-input page-chap" autocomplete="off" type="text" value="${chap.pdfPage || ''}" onchange="updateChapterPage(this.value)" placeholder="Pg No">
                    </div>
                </div>
                
                <div class="input-group" style="margin-top: 0.8rem; margin-bottom:0;">
                    <label class="input-label">Link Address</label>
                    <div style="display: flex; gap: 8px;">
                        <input class="text-input link-input" style="flex:1;" autocomplete="off" type="text" value="${chap.link || ''}" onchange="updateChapterLink(this.value)" placeholder="https://...">
                        <button class="btn-action" onclick="copyLinkFromPrevious()" title="Copy Link from Previous" style="background:white; border:1px solid #cbd5e1; padding: 0 12px;">üìã</button>
                    </div>
                </div>
            </div>
        `;

        if (!l1) { html += '<div class="empty-msg">Select or create a Level 1 tab.</div>'; container.innerHTML = html; status.innerText = 'Editing Chapter Settings'; return; }
        status.innerText = `Editing: ${l1.title}`;

        // --- LEVEL 1 CARD ---
        html += `
            <div class="section-card">
                <div class="input-group">
                    <label class="input-label">Level 1 Title</label>
                    <div style="display: flex; gap: 10px;">
                        <input class="text-input level-1-input" style="flex:1;" data-node-id="${l1.id}" autocomplete="off" type="text" value="${l1.title}" onchange="updateLevel1Title(this.value)">
                        <input class="text-input page-input page-l1" autocomplete="off" type="text" value="${l1.pdfPage || ''}" onchange="updateLevel1Page(this.value)" placeholder="Pg No">
                    </div>
                </div>
                <div class="input-group">
                    <label class="input-label">Description</label>
                    <input class="text-input desc-input" autocomplete="off" type="text" value="${l1.desc || ''}" onchange="updateLevel1Desc(this.value)">
                </div>
                <div style="margin-top:2rem; padding-top:1rem; border-top:1px solid #eee;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:1rem;">
                        <span class="input-label" style="margin:0;">Level 2 Items</span>
                        <button class="btn-add orange" onclick="addLevel2()">+ Add Level 2</button>
                    </div>
                    <div id="l2-container"></div>
                </div>
            </div>
        `;
        container.innerHTML = html;
        
        // --- LEVEL 2 & 3 GENERATION (NOW DRAGGABLE) ---
        const l2Container = document.getElementById('l2-container');
        
        l1.children.forEach((l2, l2Index) => { // Added Index
            const blk = document.createElement('div');
            
            // LEVEL 2 DRAG ATTRIBUTES
            blk.className = 'level2-block';
            blk.draggable = true; 
            blk.ondragstart = (e) => handleDragStart(e, l2Index, 'level2');
            blk.ondragover = handleEditorDragOver;
            blk.ondragleave = handleEditorDragLeave;
            blk.ondrop = (e) => handleDrop(e, l2Index, 'level2');

            // --- LEVEL 3 ITEMS ---
            let l3Html = '';
            l2.children.forEach((l3, l3Index) => { // Added Index
                // Note: We pass 'l2.id' as the parentId so we know which list we are in
                l3Html += `
                    <div class="level3-row" draggable="true" 
                         ondragstart="handleDragStart(event, ${l3Index}, 'level3', '${l2.id}')"
                         ondragover="handleEditorDragOver(event)"
                         ondragleave="handleEditorDragLeave(event)"
                         ondrop="handleDrop(event, ${l3Index}, 'level3', '${l2.id}')">
                        
                        <div style="display:flex; align-items:center; color:#cbd5e1; cursor:grab; padding-right:8px; font-size:1.2rem;">‚ãÆ‚ãÆ</div>

                        <div style="flex:1; display:flex; flex-direction:column; gap:4px;">
                            <div style="display:flex; gap: 5px;">
                                <input class="text-input level-3-input" style="flex:1; padding:0.4rem; font-size:0.9rem;" data-node-id="${l3.id}" autocomplete="off" value="${l3.title}" onchange="updateNodeTitle('${l3.id}', this.value)" placeholder="Level 3 Title">
                                <input class="text-input page-input page-l3" style="height: auto;" autocomplete="off" type="text" value="${l3.pdfPage || ''}" onchange="updateNodePage('${l3.id}', this.value)" placeholder="Pg">
                            </div>
                            <input class="text-input desc-input" autocomplete="off" style="padding:0.3rem; font-size:0.8rem;" value="${l3.desc || ''}" onchange="updateNodeDesc('${l3.id}', this.value)" placeholder="Description">
                        </div>
                        <button class="btn-icon" onclick="deleteNode('${l3.id}', '${l2.id}')">√ó</button>
                    </div>
                `;
            });

            // --- LEVEL 2 BLOCK ---
            blk.innerHTML = `
                <div class="level2-header">
                    <div class="level2-title-row" style="display:flex; align-items:center;">
                        <div style="display:flex; align-items:center; color:#cbd5e1; cursor:grab; padding-right:8px; font-size:1.2rem;">‚ãÆ‚ãÆ</div>
                        <input class="text-input level-2-input" style="flex:1;" data-node-id="${l2.id}" autocomplete="off" value="${l2.title}" onchange="updateNodeTitle('${l2.id}', this.value)" placeholder="Level 2 Title">
                        <input class="text-input page-input page-l2" autocomplete="off" type="text" value="${l2.pdfPage || ''}" onchange="updateNodePage('${l2.id}', this.value)" placeholder="Pg">
                        <button class="btn-icon" onclick="deleteNode('${l2.id}', '${l1.id}')">√ó</button>
                    </div>
                    <input class="text-input desc-input" autocomplete="off" value="${l2.desc || ''}" onchange="updateNodeDesc('${l2.id}', this.value)" placeholder="Level 2 Description">
                </div>
                <div class="level3-list">
                    ${l3Html}
                    <button class="btn-add orange" style="background:#e0f2f1; color:#059669; margin-top:0.5rem;" onclick="addLevel3('${l2.id}')">+ L3</button>
                </div>
            `;
            l2Container.appendChild(blk);
        });
    };

    // Force refresh immediately
    renderEditor();

})();
</script>
<style>
    /* Styling for the drag effect in the editor */
    .level2-block.drag-over, .level3-row.drag-over {
        border-top: 2px solid #4f46e5;
        background: #f8fafc;
    }
    .level2-block.dragging, .level3-row.dragging {
        opacity: 0.5;
        border: 1px dashed #94a3b8;
    }
</style>

<!----------------------------------------------------------------------------------------------------------------------------->

<div id="enhanced-timer" class="timer-widget collapsed" onclick="expandWidget()">
    
    <svg class="timer-svg-container">
        <defs>
            <linearGradient id="timerGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="#4f46e5" />
                <stop offset="100%" stop-color="#ec4899" />
            </linearGradient>
        </defs>
        <rect id="timer-border-rect" x="2" y="2" rx="25" ry="25" width="100%" height="100%" />
    </svg>

    <div class="timer-icon-label">‚è±</div>

    <div class="widget-content">
        <select id="timer-sound-select" class="sound-select" onchange="previewSound()" onclick="event.stopPropagation()" title="Choose Alarm Sound">
            <option value="bell">üîî Bell</option>
            <option value="beep">üìü Beep</option>
            <option value="alarm">‚è∞ Alarm</option>
        </select>

        <div class="timer-display">
            <input type="number" id="t-min" value="0" min="0" max="999" placeholder="00" onchange="validateTimerInput(this)" onclick="event.stopPropagation()">
            <span class="colon">:</span>
            <input type="number" id="t-sec" value="00" min="0" max="59" placeholder="00" onchange="validateTimerInput(this)" onclick="event.stopPropagation()">
        </div>

        <div id="ist-display" class="ist-text">IST 12:00 PM</div>

        <div class="timer-controls">
            <button id="btn-timer-toggle" onclick="toggleTimer(event)">‚ñ∂</button>
            <button id="btn-timer-reset" onclick="resetTimer(event)">‚ü≤</button>
        </div>
        
        </div>
</div>

<style>
    /* --- 1. BASE WIDGET TRANSITIONS --- */
    .timer-widget {
        position: fixed; bottom: 20px; left: 20px; z-index: 9999;
        background: rgba(255, 255, 255, 0.95); 
        backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
        
        /* Updated: Border is now handled by SVG, keep this faint or transparent */
        border: 1px solid rgba(0, 0, 0, 0.05); 
        
        box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.15);
        border-radius: 20px; 
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        overflow: visible; /* Changed to visible so SVG border doesn't clip */
        
        /* HIDDEN BY DEFAULT (For Input View) */
        display: none; 
    }

    /* Class to show widget in Visualization View */
    .timer-widget.timer-visible {
        display: flex;
    }

    /* --- NEW: SVG BORDER STYLES --- */
    .timer-svg-container {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none; /* Click-through */
        z-index: -1;
        overflow: visible;
    }

    #timer-border-rect {
        fill: none;
        stroke: url(#timerGradient);
        stroke-width: 4px;
        stroke-linecap: round;
        stroke-dasharray: 0; 
        stroke-dashoffset: 0;
        transition: stroke-dashoffset 1s linear;
        opacity: 0; /* Hidden when not running */
    }

    /* --- 2. STATE: COLLAPSED (ICON MODE) --- */
    .timer-widget.collapsed {
        width: 50px; height: 50px;
        border-radius: 50%;
        padding: 0;
        align-items: center; justify-content: center;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    .timer-widget.collapsed:hover { transform: scale(1.1); background: #fff; }
    
    .timer-icon-label {
        font-size: 24px; display: none; user-select: none;
        animation: popIn 0.3s ease;
    }
    .timer-widget.collapsed .timer-icon-label { display: block; }
    .timer-widget.collapsed .widget-content,
    .timer-widget.collapsed .ist-text { display: none; }

    /* --- 3. STATE: EXPANDED (WIDGET MODE) --- */
    .timer-widget:not(.collapsed) {
        width: 160px; height: auto;
        padding: 16px 24px;
        flex-direction: column; align-items: center; gap: 10px;
        cursor: default;
    }
    
    .widget-content {
        width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px;
        opacity: 1; transition: opacity 0.3s 0.2s; 
    }
    .timer-widget.collapsed .widget-content { opacity: 0; transition: none; }

    /* --- 4. INNER STYLES --- */
    .sound-select {
        background: rgba(0,0,0,0.04); border: none; border-radius: 4px;
        color: #475569; font-size: 0.8rem; padding: 2px 5px; width: 100%;
        outline: none; cursor: pointer; text-align: center; font-weight: 600;
    }
    .sound-select:hover { background: rgba(0,0,0,0.08); }

    .timer-display {
        display: flex; align-items: center; justify-content: center;
        font-family: 'Segoe UI', monospace; font-size: 2.2rem; font-weight: 700; 
        color: #475569; text-shadow: none;
    }
    .timer-display input {
        background: transparent; border: none; color: inherit; width: 60px;
        text-align: center; font-family: inherit; font-size: inherit; font-weight: inherit;
        outline: none; padding: 0; margin: 0;
    }
    .timer-display input:focus { border-bottom: 2px solid #4f46e5; color: #4f46e5; }
    .colon { padding-bottom: 8px; color: #94a3b8; }

    .timer-controls { display: flex; gap: 15px; width: 100%; justify-content: center; }
    .timer-controls button {
        background: rgba(0, 0, 0, 0.05); border: 1px solid rgba(0,0,0,0.05); 
        color: #64748b; border-radius: 50%; width: 40px; height: 40px; cursor: pointer;
        display: flex; align-items: center; justify-content: center; transition: all 0.2s; font-size: 1.1rem;
    }
    .timer-controls button:hover { background: rgba(0, 0, 0, 0.1); transform: scale(1.1); color: #0f172a; }
    #btn-timer-toggle { color: #10b981; } 
    .running #btn-timer-toggle { color: #f59e0b; } 

    /* --- 5. ALARM STATE (Big Clock) --- */
    .ist-text { height: 0; opacity: 0; overflow: hidden; transition: all 0.5s ease; text-align: center; }

    /* --- 7. ALARM STATE (EXPANDED & WHITE) --- */
    .timer-finished {
        /* Center Screen */
        bottom: 50% !important; left: 50% !important;
        transform: translate(-50%, 50%) scale(1.8) !important;
        background: #ffffff !important;
        border-color: #ef4444 !important;
        box-shadow: 0 0 0 10px rgba(239, 68, 68, 0.1), 0 20px 50px rgba(0,0,0,0.2) !important;
        pointer-events: auto;
        animation: breatheRed 2s infinite;
        justify-content: center;
        padding: 30px;
        min-width: 250px;
    }

    /* Hide inputs in alarm mode */
    .timer-finished .timer-display,
    .timer-finished .sound-select { display: none; }
    /* Also hide the SVG border when finished/alarming */
    .timer-finished .timer-svg-container { display: none; }

    /* Show CLOCK in alarm mode */
    .timer-finished .ist-text {
        height: auto; opacity: 1; 
        font-size: 2.2rem; 
        font-weight: 800;
        color: #475569; /* Black Text */
        margin-bottom: 20px;
        line-height: 1.2;
    }
    
    @keyframes breatheRed { 
        0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); } 
        50% { box-shadow: 0 0 0 20px rgba(239, 68, 68, 0); } 
        100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } 
    }
</style>

<script>
(function() {
    let timerInterval = null;
    let alarmInterval = null; 
    let istInterval = null;
    let totalSeconds = 0;
    let remainingSeconds = 0;
    let isRunning = false;
    let isPaused = false;
    let isAlarming = false;   

    // --- 1. GLOBAL LISTENER FOR CLICK OUTSIDE ---
    document.addEventListener('click', function(event) {
        const widget = document.getElementById('enhanced-timer');
        if (!widget) return;

        const isClickInside = widget.contains(event.target);

        // CONDITIONAL COLLAPSE
        if (!isClickInside && !isRunning && !isAlarming && !widget.classList.contains('collapsed')) {
            widget.classList.add('collapsed');
        }
    });

    // --- 2. EXPAND WIDGET ---
    window.expandWidget = function() {
        document.getElementById('enhanced-timer').classList.remove('collapsed');
    };

    // --- 3. CORE LOGIC ---
    window.toggleTimer = function(e) {
        if(e) e.stopPropagation();
        if (isAlarming) { stopAlarm(); return; }
        if (isRunning) { pauseTimer(); } else { startTimer(); }
    };

    function startTimer() {
        stopAlarm();
        const minInput = document.getElementById('t-min');
        const secInput = document.getElementById('t-sec');
        const btn = document.getElementById('btn-timer-toggle');
        const widget = document.getElementById('enhanced-timer');

        if (!isPaused) {
            let m = parseInt(minInput.value) || 0;
            let s = parseInt(secInput.value) || 0;
            if (m === 0 && s === 0) return;
            totalSeconds = m * 60 + s;
            remainingSeconds = totalSeconds;
        }

        isRunning = true;
        isPaused = false;
        
        btn.innerHTML = '‚ùö‚ùö'; 
        widget.classList.remove('collapsed'); 
        widget.classList.remove('timer-finished');
        
        minInput.readOnly = true;
        secInput.readOnly = true;

        // Initialize Progress Bar immediately
        updateProgress();

        if(timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            if (remainingSeconds > 0) {
                remainingSeconds--;
                updateDisplay();
                updateProgress();
            } else {
                timerFinished();
            }
        }, 1000);
    }

    function pauseTimer() {
        clearInterval(timerInterval);
        isRunning = false;
        isPaused = true;
        document.getElementById('btn-timer-toggle').innerHTML = '‚ñ∂';
    }

    window.resetTimer = function(e) {
        if(e) e.stopPropagation();
        stopAlarm(); 
        clearInterval(timerInterval);
        isRunning = false;
        isPaused = false;
        remainingSeconds = 0;
        totalSeconds = 0;
        
        const minInput = document.getElementById('t-min');
        const secInput = document.getElementById('t-sec');
        const btn = document.getElementById('btn-timer-toggle');
        const widget = document.getElementById('enhanced-timer');
        
        // Reset SVG
        const rect = document.getElementById('timer-border-rect');
        rect.style.strokeDasharray = '0';
        rect.style.strokeDashoffset = '0';
        rect.style.opacity = '0';

        minInput.readOnly = false;
        secInput.readOnly = false;
        minInput.value = "0";
        secInput.value = "00";
        
        btn.innerHTML = '‚ñ∂';
        widget.classList.remove('timer-finished');
    };

    function timerFinished() {
        clearInterval(timerInterval);
        isRunning = false;
        isPaused = false;
        updateDisplay();
        
        const widget = document.getElementById('enhanced-timer');
        document.getElementById('t-min').readOnly = false;
        document.getElementById('t-sec').readOnly = false;
        document.getElementById('btn-timer-toggle').innerHTML = '‚ñ†';
        
        widget.classList.add('timer-finished'); // Triggers big clock

        updateIST(); 
        istInterval = setInterval(updateIST, 1000);

        isAlarming = true;
        playSelectedSound();
        alarmInterval = setInterval(playSelectedSound, 3000);
    }

    function stopAlarm() {
        if (alarmInterval) { clearInterval(alarmInterval); alarmInterval = null; }
        if (istInterval) { clearInterval(istInterval); istInterval = null; }
        isAlarming = false;
        document.getElementById('enhanced-timer').classList.remove('timer-finished');
        document.getElementById('btn-timer-toggle').innerHTML = '‚ñ∂';
    }

    function updateIST() {
        const istLabel = document.getElementById('ist-display');
        const now = new Date();
        const options = { timeZone: 'Asia/Kolkata', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true };
        const timeString = now.toLocaleTimeString('en-IN', options);
        istLabel.innerHTML = `<div style="font-size: 0.4em; color: #64748b; letter-spacing: 2px; margin-bottom: 5px; text-transform:uppercase;">Current Time</div>${timeString}`;
    }

    function updateDisplay() {
        const m = Math.floor(remainingSeconds / 60);
        const s = remainingSeconds % 60;
        document.getElementById('t-min').value = m;
        document.getElementById('t-sec').value = s < 10 ? '0' + s : s;
    }

    // --- NEW: UPDATED PROGRESS LOGIC (CIRCULAR BORDER) ---
    function updateProgress() {
        const rect = document.getElementById('timer-border-rect');
        const widget = document.getElementById('enhanced-timer');
        
        if (totalSeconds > 0) {
            // 1. Get current widget dimensions (subtract stroke width padding)
            const w = widget.offsetWidth - 4;
            const h = widget.offsetHeight - 4;
            
            // 2. Adjust SVG Rect to fit widget
            rect.setAttribute('width', w);
            rect.setAttribute('height', h);
            
            // 3. Adjust Corner Radius (Round if collapsed, 20px if expanded)
            if (widget.classList.contains('collapsed')) {
                rect.setAttribute('rx', w / 2);
                rect.setAttribute('ry', h / 2);
            } else {
                rect.setAttribute('rx', 20);
                rect.setAttribute('ry', 20);
            }

            // 4. Calculate Path Length & Offset
            const pathLength = rect.getTotalLength();
            const percent = ((totalSeconds - remainingSeconds) / totalSeconds);
            const drawOffset = pathLength * (1 - percent); // Calculate how much to "unwind"
            
            // 5. Apply Styles
            rect.style.strokeDasharray = pathLength;
            rect.style.strokeDashoffset = drawOffset;
            rect.style.opacity = '1';
        }
    }

    window.validateTimerInput = function(input) {
        if (isAlarming) stopAlarm(); 
        if (!isRunning) { isPaused = false; }
        let val = parseInt(input.value);
        if (isNaN(val) || val < 0) val = 0;
        if (input.id === 't-sec' && val > 59) val = 59;
        if (input.id === 't-min' && val > 999) val = 999;
        if (input.id === 't-sec' && val < 10) input.value = "0" + val; else input.value = val;
    };

    // --- AUDIO ENGINE ---
    window.previewSound = function() { playSelectedSound(1); }

    function playSelectedSound(durationOverride = null) {
        const type = document.getElementById('timer-sound-select').value;
        if (type === 'bell') playBell();
        else if (type === 'beep') playBeep();
        else if (type === 'alarm') playAlarm();
    }
    // (Sound functions playBell, playBeep, playAlarm kept same as previous)
    function playBell() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const t = ctx.currentTime;
        const osc1 = ctx.createOscillator(); osc1.frequency.value = 523.25; 
        const osc2 = ctx.createOscillator(); osc2.frequency.value = 783.99; 
        const osc3 = ctx.createOscillator(); osc3.frequency.value = 1046.50; 
        const gain = ctx.createGain();
        osc1.connect(gain); osc2.connect(gain); osc3.connect(gain); gain.connect(ctx.destination);
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.3, t + 0.05); gain.gain.exponentialRampToValueAtTime(0.001, t + 3);
        osc1.start(t); osc2.start(t); osc3.start(t); osc1.stop(t+3); osc2.stop(t+3); osc3.stop(t+3);
    }
    function playBeep() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const t = ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='square'; osc.frequency.setValueAtTime(880, t);
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.1, t); gain.gain.setValueAtTime(0.1, t + 0.1); gain.gain.setValueAtTime(0, t + 0.1);
        gain.gain.setValueAtTime(0.1, t + 0.2); gain.gain.setValueAtTime(0.1, t + 0.3); gain.gain.setValueAtTime(0, t + 0.3);
        osc.connect(gain); gain.connect(ctx.destination); osc.start(t); osc.stop(t + 0.5);
    }
    function playAlarm() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const t = ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='sawtooth'; osc.frequency.setValueAtTime(440, t); osc.frequency.linearRampToValueAtTime(880, t + 0.5);
        const gain = ctx.createGain(); gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 1);
        osc.connect(gain); gain.connect(ctx.destination); osc.start(t); osc.stop(t + 1);
    }

    // --- 4. VIEW VISIBILITY TOGGLE ---
    // This hooks into your main app's switchView function
    const originalSwitchView = window.switchView;
    window.switchView = function(view) {
        // Run original logic
        if(typeof originalSwitchView === 'function') originalSwitchView(view);
        
        // Timer Logic
        const timerWidget = document.getElementById('enhanced-timer');
        if(timerWidget) {
            // Only show timer if in 'result' view
            if (view === 'result') {
                timerWidget.classList.add('timer-visible');
            } else {
                timerWidget.classList.remove('timer-visible');
            }
        }
    };
    
    // Initial Check
    setTimeout(() => {
        const isResult = document.getElementById('result-view')?.classList.contains('active-view');
        if(isResult) document.getElementById('enhanced-timer')?.classList.add('timer-visible');
    }, 500);

})();
</script>

<!----------------------------------------------------------------------------------------------------------------------------->

</body>
</html>
